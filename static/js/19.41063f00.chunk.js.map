{"version":3,"sources":["modelapi.js","covid19util.js","scorePage/scoreGraph.js","scorePage/newScoreGraph.js","scorePage/scoreMap.js","scorePage/scorePage.js"],"names":["API_BASE_URL","process","ModelAPI","callback","endpoint","axios","get","then","res","allAreas","data","allModels","infectionModels","deathModels","params","currentDate","latestDate","total_confirmed","Global","TotalConfirmed","total_deaths","TotalDeaths","totalConfirmed","totalDeaths","areaToStr","a","country","state","DashedLine","series","lineGenerator","xScale","yScale","map","id","color","predicted","distancing","style","strokeWidth","strokeDasharray","key","d","x","y","fill","stroke","theme","axis","ticks","text","fontSize","legend","legends","Component","NewScoreGraph","parseData","scoreType","firstArea","Object","keys","observed_rt","value","idx","dataSet","name","date","split","conf","i","length","observed_mrf","this","props","chartData","areas","colors","area","strokeColor","index","red","gold","lime","cyan","geekblue","purple","magenta","getLineColor","push","lines","type","dataKey","width","direction","height","margin","top","right","left","bottom","dy","position","angle","label","iconSize","am4core","am4themes_animated","ScoreMap","onShowState","setState","showState","modelAPI","areasList","worldSeries","usaSeries","triggerRef","args","arguments","scores_all","weeks","scores","heatmapData","iso_2","initChart","updateChart","all_mrf_scores","latestWeek","chart","am4maps","projection","Mercator","createChartSeries","geodata","am4geodata_worldLow","exclude","am4geodata_usaLow","disabled","stateSeries","initChartInterface","seriesProps","polygonTemplate","assign","mapPolygons","template","heatRules","property","target","min","max","minValue","maxValue","tooltipText","nonScalingStroke","states","create","properties","cursorOverStyle","pointer","onMapClick","onNoData","events","on","e","dataItem","dataContext","zoomControl","button","chartContainer","createChild","togglable","padding","align","marginRight","isActive","forEach","s","dispose","Option","ScorePage","componentDidMount","formRef","React","createRef","latest_score_date","firstDate","addAreaByStr","current","setFieldsValue","fetchData","dynamicMapOn","bindRef","ref","onAlertClose","noDataError","errorDescription","generateMarks","lastDate","Date","setDate","getDate","marks","getMonth","handleScoreTypeSelect","mainGraphData","bind","removeAreaByStr","onValuesChange","onWeeksChange","switchDynamicMap","areaIsSelected","newAreaStr","includes","areaStr","areaObj","words","trim","strToArea","prevState","targetAreaStr","filter","reduce","newMainGraphData","changedValues","allValues","prevAreas","newAreas","areasToAdd","areasToRemove","checked","countryOptions","sort","month","formatted_current_date","className","justify","span","message","description","closable","onClose","Item","rules","required","mode","placeholder","initialValue","onAfterChange","Group","onChange","PureComponent"],"mappings":"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","file":"static/js/19.41063f00.chunk.js","sourcesContent":["import axios from \"axios\";\r\n\r\n// TODO: Update with actual backend URL once backend is up and running.\r\nconst API_BASE_URL = process.env.REACT_APP_BACKEND_BASE_URL;\r\n\r\nclass ModelAPI {\r\n  affected_by(callback) {}\r\n\r\n  areas(callback) {\r\n    const endpoint = `${API_BASE_URL}/areas`;\r\n    axios.get(endpoint).then(res => {\r\n      const allAreas = res.data;\r\n      callback(allAreas);\r\n    });\r\n  }\r\n\r\n  models(callback) {\r\n    const endpoint = `${API_BASE_URL}/models`;\r\n    axios.get(endpoint).then(res => {\r\n      const allModels = res.data;\r\n      callback(allModels);\r\n    });\r\n  }\r\n\r\n  infection_models(callback) {\r\n    const endpoint = `${API_BASE_URL}/infection_models`;\r\n    axios.get(endpoint).then(res => {\r\n      const infectionModels = res.data;\r\n      callback(infectionModels);\r\n    });\r\n  }\r\n\r\n  death_models(callback) {\r\n    const endpoint = `${API_BASE_URL}/death_models`;\r\n    axios.get(endpoint).then(res => {\r\n      const deathModels = res.data;\r\n      callback(deathModels);\r\n    });\r\n  }\r\n\r\n  cumulative_infections(callback) {\r\n    const endpoint = `${API_BASE_URL}/cumulative_infections`;\r\n    axios.get(endpoint).then(res => callback(res.data));\r\n  }\r\n\r\n  /**\r\n   * Params should have 'days', 'model'\r\n   */\r\n  predict_all(params, callback) {\r\n    const endpoint = `${API_BASE_URL}/predict_all`;\r\n    axios.get(endpoint, {\r\n      params: params\r\n    }).then(res => callback(res.data));\r\n  }\r\n\r\n  /**\r\n   * Params should have 'country', 'state', 'days', 'distancingOn,' 'distancingOff'\r\n   */\r\n  predict(params, callback) {\r\n    const endpoint = `${API_BASE_URL}/predict`;\r\n    axios\r\n      .get(endpoint, {\r\n        params: params\r\n      })\r\n      .then(res => {\r\n        callback(res.data);\r\n      });\r\n  }\r\n\r\n  // get the current date of observed data\r\n  getCurrentDate(callback) {\r\n    const endpoint =  `${API_BASE_URL}/current_date`;\r\n    axios.get(endpoint).then(res => {\r\n      const currentDate = res.data;\r\n      callback(currentDate);\r\n    });\r\n  }\r\n\r\n  //check previous data \r\n  checkHistory(params,callback)\r\n  {\r\n    const endpoint = `${API_BASE_URL}/check_history`;\r\n    axios\r\n      .get(endpoint, {\r\n        params: params\r\n      })\r\n      .then(res => {\r\n        callback(res.data);\r\n      });\r\n  }\r\n\r\n  //cumulative for history\r\n  history_cumulative(params, callback) {\r\n    const endpoint = `${API_BASE_URL}/history_cumulative`;\r\n    axios\r\n      .get(endpoint, {\r\n        params: params\r\n      })\r\n      .then(res => {\r\n        callback(res.data);\r\n      });\r\n  }\r\n\r\n  //get all quarantine score at a week, parameter: weeks\r\n  scores_all(params, callback) {\r\n    const endpoint = `${API_BASE_URL}/scores_all`;\r\n    axios\r\n      .get(endpoint, {\r\n        params: params\r\n      })\r\n      .then(res => {\r\n        callback(res.data);\r\n      });\r\n  }\r\n\r\n  //get all, parameter: state, country, weeks\r\n  scores(params, callback) {\r\n    const endpoint = `${API_BASE_URL}/scores`;\r\n    axios\r\n      .get(endpoint, {\r\n        params: params\r\n      })\r\n      .then(res => {\r\n        callback(res.data);\r\n      });\r\n  }\r\n\r\n  //get the latest date which \r\n  latest_score_date(callback) {\r\n    const endpoint =  `${API_BASE_URL}/latest_score_date`;\r\n    axios.get(endpoint).then(res => {\r\n      const latestDate = res.data;\r\n      callback(latestDate);\r\n    });\r\n  }\r\n\r\n  //get the death at latest time\r\n  cumulative_death(params, callback) {\r\n    const endpoint = `${API_BASE_URL}/cumulative_death`;\r\n    axios\r\n      .get(endpoint, {\r\n        params: params\r\n      })\r\n      .then(res => {\r\n        callback(res.data);\r\n      });\r\n  }\r\n\r\n  //get all mfr scores at a week: parameter week\r\n  all_mrf_scores(params, callback) {\r\n    const endpoint = `${API_BASE_URL}/all_mrf_scores`;\r\n    axios\r\n      .get(endpoint, {\r\n        params: params\r\n      })\r\n      .then(res => {\r\n        callback(res.data);\r\n      });\r\n  }\r\n\r\n  //fetch real time data for the whole world\r\n  real_time(callback) {\r\n    const EXTERNAL_API = \"https://api.covid19api.com/summary\";\r\n    axios\r\n      .get(EXTERNAL_API)\r\n      .then(res => {\r\n        const total_confirmed = res.data.Global.TotalConfirmed;\r\n        const total_deaths = res.data.Global.TotalDeaths;\r\n        const global = {\r\n          totalConfirmed: total_confirmed,\r\n          totalDeaths: total_deaths\r\n        }\r\n        callback(global);\r\n      }\r\n    )\r\n  }\r\n}\r\n\r\nexport default ModelAPI;\r\n","export function areaToStr(a) {\r\n  return `${a.country}${a.state ? \" / \" + a.state : \"\"}`;\r\n}\r\n\r\nexport function strToArea(s) {\r\n  const words = s.split(\"/\");\r\n\r\n  return {\r\n    country: words[0].trim(),\r\n    state: words.length === 2 ? words[1].trim() : \"\"\r\n  };\r\n}\r\n\r\nexport function modelToStr(a) {\r\n  return `${a.name}`;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { ResponsiveLine} from \"@nivo/line\";\r\nimport moment from \"moment\";\r\nimport numeral from \"numeral\";\r\nimport {\r\n  red,\r\n  gold,\r\n  lime,\r\n  cyan,\r\n  geekblue,\r\n  purple,\r\n  magenta\r\n} from \"@ant-design/colors\";\r\n\r\nfunction getLineColor(index) {\r\n  const colors = [\r\n    red,\r\n    gold,\r\n    lime,\r\n    cyan,\r\n    geekblue,\r\n    purple,\r\n    magenta\r\n  ];\r\n\r\n  return colors[index % colors.length];\r\n}\r\n\r\nconst DashedLine = ({ series, lineGenerator, xScale, yScale }) => {\r\n  return series.map(({ id, data, color, predicted, distancing }) => {\r\n    let style = {\r\n      strokeWidth: 5\r\n    };\r\n\r\n    // Add custom style if predicted.\r\n    if (predicted) {\r\n      if (distancing) {\r\n        style.strokeDasharray = \"6, 4\";\r\n      } else {\r\n        // Display a sparser pattern for no social distancing.\r\n        style.strokeDasharray = \"2, 6\";\r\n      }\r\n    }\r\n\r\n    return (\r\n      <path\r\n        key={id}\r\n        d={lineGenerator(\r\n          data.map(d => ({\r\n            x: xScale(d.data.x),\r\n            y: yScale(d.data.y)\r\n          }))\r\n        )}\r\n        fill=\"none\"\r\n        stroke={color}\r\n        style={style}\r\n      />\r\n    );\r\n  });\r\n};\r\n\r\nconst theme = {\r\n  axis: {\r\n    ticks: {\r\n      text: {\r\n        fontSize: 18\r\n      }\r\n    },\r\n    legend: {\r\n      text: {\r\n        fontSize: 18\r\n      }\r\n    }\r\n  },\r\n  legends: {\r\n    text: {\r\n      fontSize: 18\r\n    }\r\n  }\r\n};\r\n\r\nclass ScoreGraph extends Component {\r\n  parseDate(dateStr) {\r\n    let [year, month, day] = dateStr.split(\"-\").map(Number);\r\n    // Month in JS is 0-based.\r\n    month -= 1;\r\n    return new Date(year, month, day);\r\n  }\r\n\r\n  /**\r\n   * Given a time series returned by the predict endpoint, getCumulativeData\r\n   * returns it in Nivo format.\r\n   */\r\n  getCumulativeData(data) {\r\n    return data.map(d => ({\r\n      x: this.parseDate(d.date),\r\n      y: d.value\r\n    }));\r\n  }\r\n\r\n  // processData properly formats the given data, and performs special\r\n  // operations based on parameter values.\r\n  processData(data) {\r\n    console.log(data);\r\n    let retData = this.getCumulativeData(data);\r\n\r\n    return retData;\r\n  }\r\n\r\n  /**\r\n   * getDataMax returns the maximum value present in the data supplied to the\r\n   * graph.\r\n   */\r\n  getDataMax() {\r\n    const { data } = this.props;\r\n\r\n    let max = 0;\r\n\r\n    Object.keys(data).forEach(area => {\r\n      const { observed } = data[area];\r\n      max = Math.max(max, Math.max(...observed.map(({ value }) => value)));\r\n    });\r\n\r\n    return max;\r\n  }\r\n\r\n  /**\r\n   * getYAxisProps returns the corresponding Nivo line props for supporting\r\n   * different Y axis types (linear and log).\r\n   */\r\n  getYAxisProps() {\r\n    const linearAxisLeft = {\r\n      // Format large y numbers as their abbreviations.\r\n      format: y => numeral(y).format(\"0.[0]a\"),\r\n      orient: \"left\",\r\n      tickSize: 5,\r\n      tickPadding: 5,\r\n      tickRotation: 0,\r\n      legend: \"Dynamic Reproduction Number\",\r\n      legendOffset: -60,\r\n      legendPosition: \"middle\"\r\n    };\r\n\r\n    let logTickValues = [];\r\n    for (let i = 0; i <= Math.ceil(Math.log10(this.getDataMax())); i++) {\r\n      logTickValues.push(Math.pow(10, i));\r\n    }\r\n\r\n    // The 'axisLeft' prop for log scale is the same as for linear axis, except\r\n    // that the tick values must be supplied.\r\n    const logAxisLeft = {\r\n      ...linearAxisLeft,\r\n      tickValues: logTickValues\r\n    };\r\n\r\n    return {\r\n      axisLeft: linearAxisLeft,\r\n      yScale: {\r\n        type: \"linear\",\r\n        min: \"auto\",\r\n        max: \"auto\"\r\n      }\r\n    };\r\n  }\r\n\r\n  render() {\r\n    let { data } = this.props;\r\n    // chartData contains the data that we will pass into Nivo line chart.\r\n    let chartData = [];\r\n    // colors holds hex values for each line in the chart.\r\n    let colors = [];\r\n    // Sort the data by area name (so we have a consistent coloring) and then\r\n    // loop over each area.\r\n    Object.keys(data)\r\n      .sort()\r\n      .forEach((area, idx) => {\r\n        const lineColor = getLineColor(idx);\r\n        const observedData = data[area].observed;\r\n        const upperBound = observedData.map(data=>{\r\n           return {\r\n             date: data.date,\r\n             value: data.value + data.conf\r\n           }\r\n        });\r\n        const lowerBound = observedData.map(data=>{\r\n          return {\r\n            date: data.date,\r\n            value: data.value - data.conf\r\n          }\r\n       });\r\n        // Add the mean\r\n        chartData.push({\r\n          id: area,\r\n          data: this.processData(observedData),\r\n          // 'predicted' is a custom prop that we add so later we can tell the\r\n          // difference between observed/predicted data when drawing the lines.\r\n          predicted: false\r\n        });\r\n\r\n        colors.push(lineColor[3]);\r\n\r\n        //add the upperbound\r\n        chartData.push({\r\n          id: `${area} upper bound`,\r\n          data: this.processData(upperBound),\r\n          // 'predicted' is a custom prop that we add so later we can tell the\r\n          // difference between observed/predicted data when drawing the lines.\r\n          predicted: false\r\n        });\r\n        colors.push(lineColor[3]);\r\n\r\n        //add the lowerbound\r\n        chartData.push({\r\n          id: `${area} lower bound`,\r\n          data: this.processData(lowerBound),\r\n          // 'predicted' is a custom prop that we add so later we can tell the\r\n          // difference between observed/predicted data when drawing the lines.\r\n          predicted: false\r\n        });\r\n        colors.push(lineColor[3]);\r\n      });\r\n\r\n    // Determine whether we need to show weeks or months on the X axis.\r\n    let tickValues = \"every week\";\r\n\r\n    if (chartData.length > 0) {\r\n      // Calculate the minimum and maximum dates present in the data.\r\n      let minDate = chartData[0].data[0].x;\r\n      let maxDate = chartData[0].data[0].x;\r\n\r\n      chartData.forEach(({ data }) => {\r\n        data.forEach(({ x }) => {\r\n          minDate = Math.min(minDate, x);\r\n          maxDate = Math.max(maxDate, x);\r\n        });\r\n      });\r\n\r\n      minDate = moment(minDate);\r\n      maxDate = moment(maxDate);\r\n\r\n      // Switch to 'every month' if the date range is over a certain threshold.\r\n      const diffInDays = maxDate.diff(minDate, \"days\");\r\n      if (diffInDays > 150) {\r\n        tickValues = \"every month\";\r\n      }\r\n    }\r\n\r\n    return (\r\n      <ResponsiveLine\r\n        data={chartData}\r\n        colors={colors}\r\n        //50,50,50,80\r\n        margin={{ top: 10, right: 50, bottom: 70, left: 100 }}\r\n        xScale={{\r\n          type: \"time\",\r\n          format: \"native\",\r\n          precision: \"day\"\r\n        }}\r\n        axisBottom={{\r\n          // tickValues determines how often / with what values our 'format'\r\n          // func is called.\r\n          tickValues: tickValues,\r\n          // A custom 'format' func is required since all the x values are\r\n          // javascript Date objects.\r\n          format: date => {\r\n            return moment(date).format(\"M/D\");\r\n          },\r\n          orient: \"bottom\",\r\n          tickSize: 5,\r\n          tickPadding: 5,\r\n          tickRotation: 0,\r\n          legend: \"Date\",\r\n          legendOffset: 36,\r\n          legendPosition: \"middle\"\r\n        }}\r\n        // Set up the Y axis.\r\n        {...this.getYAxisProps()}\r\n        enableSlices=\"x\"\r\n        sliceTooltip={({ slice }) => {\r\n          return (\r\n            <div\r\n              style={{\r\n                background: \"white\",\r\n                padding: \"9px 12px\",\r\n                border: \"1px solid #ccc\"\r\n              }}\r\n            >\r\n              <div>\r\n                {// Grab the date from the first point, this will be the title of\r\n                // the tooltip.\r\n                moment(slice.points[0].data.x).format(\"MMM Do YYYY\")}\r\n              </div>\r\n              {slice.points.map(point => (\r\n                <div\r\n                  key={point.id}\r\n                  style={{\r\n                    color: point.serieColor,\r\n                    padding: \"3px 0\"\r\n                  }}\r\n                >\r\n                  <strong>{point.serieId}</strong>[\r\n                  {numeral(point.data.yFormatted).format(\"0.[0]a\")}]\r\n                </div>\r\n              ))}\r\n            </div>\r\n          );\r\n        }}\r\n        legends={[\r\n          {\r\n            anchor: \"top-left\",\r\n            direction: \"column\",\r\n            justify: false,\r\n            translateX: 0,\r\n            translateY: 0,\r\n            itemsSpacing: 0,\r\n            itemDirection: \"left-to-right\",\r\n            itemWidth: 80,\r\n            itemHeight: 20,\r\n            itemOpacity: 0.75,\r\n            symbolSize: 12,\r\n            symbolShape: \"circle\",\r\n            symbolBorderColor: \"rgba(0, 0, 0, .5)\",\r\n            effects: [\r\n              {\r\n                on: \"hover\",\r\n                style: {\r\n                  itemBackground: \"rgba(0, 0, 0, .03)\",\r\n                  itemOpacity: 1\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        ]}\r\n        layers={[\r\n          \"grid\",\r\n          \"markers\",\r\n          \"areas\",\r\n          \"crosshair\",\r\n          DashedLine,\r\n          \"slices\",\r\n          \"points\",\r\n          \"axes\",\r\n          \"legends\"\r\n        ]}\r\n        theme={theme}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default ScoreGraph;\r\n","import React, { Component } from \"react\";\r\nimport {\r\n    red,\r\n    gold,\r\n    lime,\r\n    cyan,\r\n    geekblue,\r\n    purple,\r\n    magenta\r\n  } from \"@ant-design/colors\";\r\n\r\nimport { \r\n    LineChart, \r\n    Line,\r\n    CartesianGrid,\r\n    XAxis,\r\n    YAxis,\r\n    Tooltip,\r\n    Legend,\r\n    Label,\r\n    ErrorBar,\r\n    ReferenceLine\r\n} from 'recharts';\r\n\r\nfunction getLineColor(index) {\r\n    const colors = [\r\n        red,\r\n        gold,\r\n        lime,\r\n        cyan,\r\n        geekblue,\r\n        purple,\r\n        magenta\r\n    ];\r\n\r\n    return colors[index % colors.length];\r\n}\r\n\r\n\r\n\r\nclass NewScoreGraph extends Component {\r\n    parseData = (data, scoreType) => { \r\n        const firstArea = Object.keys(data)[0];\r\n        if (data[firstArea])\r\n        {\r\n            if (scoreType === \"reproduction\")\r\n            {\r\n                const chartData = data[firstArea].observed_rt.map((value,idx) => {\r\n                    let date = value.date.split(\"-\")[1] + \"/\" + value.date.split(\"-\")[2]\r\n                    let dataSet = {name: date};\r\n                    dataSet[Object.keys(data)[0]] = value.value;\r\n                    dataSet[`error${Object.keys(data)[0]}`] = value.conf;\r\n                    for (let i = 1; i < Object.keys(data).length; ++i)\r\n                    {\r\n                        dataSet[Object.keys(data)[i]] = data[Object.keys(data)[i]].observed_rt[idx].value;\r\n                        dataSet[`error${Object.keys(data)[i]}`] = data[Object.keys(data)[i]].observed_rt[idx].conf;\r\n                    }\r\n                    return dataSet\r\n                });\r\n                return chartData;\r\n            }\r\n            else\r\n            {\r\n                const chartData = data[firstArea].observed_mrf.map((value,idx) => {\r\n                    let date = value.date.split(\"-\")[1] + \"/\" + value.date.split(\"-\")[2]\r\n                    let dataSet = {name: date};\r\n                    dataSet[Object.keys(data)[0]] = value.value;\r\n                    dataSet[`error${Object.keys(data)[0]}`] = value.conf;\r\n                    for (let i = 1; i < Object.keys(data).length; ++i)\r\n                    {\r\n                        dataSet[Object.keys(data)[i]] = data[Object.keys(data)[i]].observed_mrf[idx].value;\r\n                        dataSet[`error${Object.keys(data)[i]}`] = data[Object.keys(data)[i]].observed_mrf[idx].conf;\r\n                    }\r\n                    return dataSet\r\n                });\r\n                return chartData;\r\n            }\r\n        }\r\n    }\r\n    \r\n    render(){\r\n        let {data, date, scoreType} = this.props;\r\n        //map data\r\n        const chartData = this.parseData(data, scoreType);\r\n        //areas and line color\r\n        const areas = Object.keys(data);\r\n        let colors = [];\r\n        areas.map((area, idx)=>{\r\n            let strokeColor = getLineColor(idx);\r\n            colors.push(strokeColor);\r\n            return 0;\r\n        });\r\n        let lines = [];\r\n        for (let i = 0; i < areas.length; ++i)\r\n        {\r\n            lines.push(\r\n                <Line type=\"monotone\" key={i} dataKey={areas[i]} stroke={colors[i][3]} strokeWidth={5}>\r\n                    <ErrorBar dataKey={`error${areas[i]}`} width={15} strokeWidth={2} stroke={colors[i][6]} direction=\"y\" />\r\n                </Line>\r\n            )\r\n        }\r\n        return(\r\n            <LineChart width={1400} height={300} data={chartData}\r\n            margin={{ top: 40, right: 30, left: 40, bottom: 5 }}>\r\n            <CartesianGrid strokeDasharray=\"3 3\" />\r\n            <XAxis dataKey=\"name\" />\r\n            <YAxis>\r\n                {scoreType===\"reproduction\"?\r\n                <Label value=\"Dynamic Reproduction Number\" dy = {90} position=\"insideLeft\" angle={-90} fontSize={15} />\r\n                 :\r\n                <Label value=\"MFR Score\" dy = {45} position=\"insideLeft\" angle={-90} fontSize={15} />\r\n                }\r\n            </YAxis>\r\n            <Tooltip />\r\n            <ReferenceLine x={date} stroke=\"green\" strokeWidth={5} fontSize={20} \r\n                            label={{position: 'top', value: 'selected date', fill: 'green', fontSize: 15}} \r\n            strokeDasharray=\"10 10\"/>\r\n            {scoreType === \"reproduction\"? \r\n            <ReferenceLine y={1} stroke=\"SandyBrown\" strokeWidth={5} strokeDasharray=\"3 3\" \r\n                            label={{position: 'left', value: '', fill: 'red', fontSize: 20}} \r\n            />\r\n            :null}\r\n            <Legend iconSize={40}/>\r\n            {lines}\r\n            </LineChart>\r\n        );\r\n    }\r\n}\r\n\r\nexport default NewScoreGraph;\r\n\r\n  ","import React, { Component } from \"react\";\r\nimport { Circle, Map, Marker, Popup, TileLayer } from \"react-leaflet\";\r\nimport ModelAPI from \"../modelapi\";\r\nimport { areaToStr, strToArea } from \"../covid19util\";\r\n\r\nimport * as am4core from \"@amcharts/amcharts4/core\";\r\nimport * as am4maps from \"@amcharts/amcharts4/maps\";\r\nimport am4geodata_worldLow from \"@amcharts/amcharts4-geodata/worldLow\";\r\nimport am4geodata_usaLow from \"@amcharts/amcharts4-geodata/usaLow\";\r\nimport am4themes_animated from \"@amcharts/amcharts4/themes/animated\";\r\n\r\nconst HEAT_MAP_MIN_COLOR = \"#85DB50\";\r\nconst HEAT_MAP_MAX_COLOR = \"#F33A21\";\r\nconst MAP_HOVER_COLOR = \"#83FE00\";\r\n\r\nam4core.useTheme(am4themes_animated);\r\n\r\nclass ScoreMap extends Component {\r\n    constructor() {\r\n      super();\r\n      this.modelAPI = new ModelAPI();\r\n  \r\n      this.state = {\r\n        areasList : [],\r\n        showState: false,\r\n        worldSeries: {},\r\n        usaSeries: {}\r\n      }\r\n  \r\n      this.modelAPI.areas(allAreas =>\r\n        this.setState({\r\n          areasList: allAreas\r\n        })\r\n      );\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.triggerRef(this);\r\n    }\r\n\r\n    onShowState = (value) =>{\r\n        this.setState({\r\n          showState: value\r\n        });\r\n    }\r\n\r\n    fetchData()\r\n    {\r\n        var args = arguments;\r\n        const {scoreType} = this.props;\r\n        if (!args[0]) {\r\n          //without dynamic map,show to latestscore\r\n          if (scoreType === \"reproduction\")\r\n          {\r\n            this.modelAPI.scores_all(\r\n              {\r\n                  weeks: this.props.latestWeek,\r\n              } , scores => {\r\n                let heatmapData = scores.map(d => {\r\n                return {\r\n                  id: d.area.iso_2,\r\n                  value: d.value > 0 ? d.value: 0,\r\n                  area: d.area,\r\n                  conf: d.conf\r\n                };\r\n              });\r\n              this.setState({ heatmapData }, this.initChart);\r\n            });\r\n          }\r\n          else\r\n          {\r\n            this.modelAPI.all_mrf_scores(\r\n              {\r\n                  weeks: this.props.latestWeek,\r\n              } , scores => {\r\n                let heatmapData = scores.map(d => {\r\n                return {\r\n                  id: d.area.iso_2,\r\n                  value: d.value > 0 ? d.value: 0,\r\n                  area: d.area,\r\n                  conf: d.conf\r\n                };\r\n              });\r\n              this.setState({ heatmapData }, this.initChart);\r\n            });\r\n          }  \r\n        } else {\r\n          if (scoreType === \"reproduction\")\r\n          {\r\n            this.modelAPI.scores_all(\r\n              {\r\n                  weeks: this.props.weeks,\r\n              }, scores =>{\r\n              let heatmapData = scores.map(d => {\r\n                  return {\r\n                      id: d.area.iso_2,\r\n                      value: d.value > 0 ? d.value: 0,\r\n                      area: d.area\r\n                  };\r\n                  });\r\n                  if (args[1])\r\n                  {\r\n                    this.setState({ heatmapData }, this.initChart);\r\n                  }\r\n                  else\r\n                  {\r\n                    this.setState({ heatmapData }, this.updateChart);\r\n                  }              \r\n              });\r\n          }\r\n          else\r\n          {\r\n            this.modelAPI.all_mrf_scores(\r\n              {\r\n                  weeks: this.props.weeks,\r\n              }, scores =>{\r\n              let heatmapData = scores.map(d => {\r\n                  return {\r\n                      id: d.area.iso_2,\r\n                      value: d.value > 0 ? d.value: 0,\r\n                      area: d.area\r\n                  };\r\n                  });\r\n                  if (args[1])\r\n                  {\r\n                    this.setState({ heatmapData }, this.initChart);\r\n                  }\r\n                  else\r\n                  {\r\n                    this.setState({ heatmapData }, this.updateChart);\r\n                  }\r\n              });\r\n          }\r\n           \r\n        }\r\n    }\r\n\r\n    initChart() {\r\n        // Create map instance\r\n        this.chart = am4core.create(\"chartdiv\", am4maps.MapChart);\r\n        // Set projection\r\n        this.chart.projection = new am4maps.projections.Mercator();\r\n        let worldSeries = this.chart.series.push(new am4maps.MapPolygonSeries());\r\n        worldSeries = this.createChartSeries(worldSeries, {\r\n          geodata: am4geodata_worldLow,\r\n          exclude: [\"AQ\"],\r\n          data: this.state.heatmapData\r\n        });\r\n        let usaSeries = this.chart.series.push(new am4maps.MapPolygonSeries());\r\n        usaSeries = this.createChartSeries(usaSeries, {\r\n          geodata: am4geodata_usaLow,\r\n          data: this.state.heatmapData,\r\n          disabled: !this.state.showState\r\n        });\r\n        this.stateSeries = [usaSeries];\r\n        this.initChartInterface();\r\n        this.setState({\r\n          worldSeries,\r\n          usaSeries\r\n        });\r\n    }\r\n\r\n    updateChart(){\r\n      let worldSeries = this.state.worldSeries;\r\n      let usaSeries = this.state.usaSeries;\r\n      worldSeries.data = this.state.heatmapData;\r\n      usaSeries.data = this.state.heatmapData;\r\n    }\r\n\r\n    createChartSeries(series, seriesProps) {\r\n        const {scoreType} = this.props;\r\n        series = Object.assign(series, seriesProps);\r\n        let polygonTemplate = series.mapPolygons.template;\r\n        if (scoreType === \"reproduction\")\r\n        {\r\n          series.heatRules.push({\r\n            property: \"fill\",\r\n            target: polygonTemplate,\r\n            min: am4core.color(HEAT_MAP_MIN_COLOR),\r\n            max: am4core.color(HEAT_MAP_MAX_COLOR),\r\n            minValue: 0,\r\n            maxValue: 4\r\n          });\r\n        }\r\n        else\r\n        {\r\n          series.heatRules.push({\r\n            property: \"fill\",\r\n            target: polygonTemplate,\r\n            min: am4core.color(HEAT_MAP_MIN_COLOR),\r\n            max: am4core.color(HEAT_MAP_MAX_COLOR),\r\n            minValue: 0,\r\n            maxValue: 0.4\r\n          });\r\n        }  \r\n        // Configure series tooltip. Display the true value of infections.\r\n        polygonTemplate.tooltipText = \"{name}: {value}\";\r\n        polygonTemplate.nonScalingStroke = true;\r\n        polygonTemplate.strokeWidth = 0.5;\r\n    \r\n        // Create hover state and set alternative fill color.\r\n        let hs = polygonTemplate.states.create(\"hover\");\r\n        hs.properties.fill = am4core.color(MAP_HOVER_COLOR);\r\n    \r\n        // Change mouse cursor to pointer.\r\n        polygonTemplate.cursorOverStyle = am4core.MouseCursorStyle.pointer;\r\n    \r\n        // Create click handler. Apparently ALL the series in the chart must have\r\n        // click handlers activated, so if this function is not running double-check\r\n        // that other series also have click handlers.\r\n        const { onMapClick, onNoData} = this.props;\r\n        polygonTemplate.events.on(\"hit\", e => {\r\n          const { id, value, area, name} = e.target.dataItem.dataContext;\r\n          if (area){\r\n            onMapClick(area);\r\n          }\r\n          else\r\n          {\r\n            onNoData(name);\r\n          }\r\n        });\r\n        return series;\r\n    }\r\n\r\n    initChartInterface() {\r\n        // Create a zoom control.\r\n        const {showState} = this.state;\r\n        this.chart.zoomControl = new am4maps.ZoomControl();\r\n        this.chart.zoomControl.cursorOverStyle = am4core.MouseCursorStyle.pointer;\r\n    \r\n        // Create a toggle button to show/hide states/provinces.\r\n        let button = this.chart.chartContainer.createChild(am4core.Button);\r\n        //button.label.text = \"Show States/Provinces\";\r\n        button.label.text = `${\r\n          showState ? \"Hide\" : \"Show\"\r\n          } States/Provinces`;\r\n        button.togglable = true;\r\n        button.padding(5, 5, 5, 5);\r\n        button.align = \"right\";\r\n        button.marginRight = 15;\r\n        button.cursorOverStyle = am4core.MouseCursorStyle.pointer;\r\n        button.events.on(\"hit\", () => {\r\n          this.onShowState(button.isActive);\r\n          const {showState} = this.state;\r\n          this.stateSeries.forEach(s => (s.disabled = !showState));\r\n          button.label.text = `${\r\n            showState ? \"Hide\" : \"Show\"\r\n            } States/Provinces`;\r\n        });\r\n      }\r\n\r\n      componentWillUnmount() {\r\n        if (this.chart) {\r\n          this.chart.dispose();\r\n        }\r\n      }\r\n\r\n    render() {\r\n        return <div id=\"chartdiv\"></div>;\r\n    }\r\n}\r\n\r\nexport default ScoreMap;","import React, { PureComponent } from \"react\";\r\nimport ModelAPI from \"../modelapi\";\r\nimport { areaToStr, strToArea} from \"../covid19util\";\r\nimport ScoreGraph from \"./scoreGraph\";\r\nimport NewScoreGraph from \"./newScoreGraph\";\r\nimport ScoreMap from './scoreMap';\r\nimport \"./scorePage.css\";\r\n\r\nimport {\r\n    Form,\r\n    Select,\r\n    Slider,\r\n    Switch,\r\n    Alert,\r\n    Row,\r\n    Col,\r\n    Radio\r\n  } from \"antd\";\r\n\r\nconst { Option } = Select;\r\n\r\nclass ScorePage extends PureComponent{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            areas: this.props.areas || [],\r\n            areasList: [],\r\n            latestDate: \"\",\r\n            firstDate: \"\",\r\n            mainGraphData: {},\r\n            weeks: this.props.weeks || 0, // will later be set to be the weeks to the latest date as initial value\r\n            latestWeek: 0, //will change later and remain unchange until database updated\r\n            dynamicMapOn: false,\r\n            noDataError: false,\r\n            errorDescription: \"\",\r\n            scoreType: \"reproduction\"\r\n        }  \r\n        \r\n        this.addAreaByStr = this.addAreaByStr.bind(this);\r\n        this.removeAreaByStr = this.removeAreaByStr.bind(this);\r\n        this.onValuesChange = this.onValuesChange.bind(this);\r\n        this.onMapClick = this.onMapClick.bind(this);\r\n        this.onWeeksChange = this.onWeeksChange.bind(this);\r\n        this.switchDynamicMap = this.switchDynamicMap.bind(this);\r\n        this.onAlertClose = this.onAlertClose.bind(this);\r\n        this.onNoData = this.onNoData.bind(this);\r\n        this.generateMarks = this.generateMarks.bind(this);\r\n        this.handleScoreTypeSelect = this.handleScoreTypeSelect.bind(this);\r\n    }\r\n\r\n    componentDidMount = ()=>{\r\n        this.formRef = React.createRef();\r\n    \r\n        this.modelAPI = new ModelAPI();\r\n\r\n        this.modelAPI.latest_score_date(latestDate => \r\n            this.setState({\r\n                latestDate: latestDate[0].date,\r\n                weeks: latestDate[0].weeks,\r\n                latestWeek: latestDate[0].weeks,\r\n                firstDate: latestDate[0].firstDate\r\n            }, ()=>{\r\n                this.addAreaByStr('US');\r\n                this.formRef.current.setFieldsValue({\r\n                    weeks: this.state.latestWeek,\r\n                });\r\n                this.map.fetchData(this.state.dynamicMapOn);\r\n            })\r\n        );\r\n    \r\n        this.modelAPI.areas(allAreas =>\r\n          this.setState({\r\n            areasList: allAreas\r\n          })\r\n        );\r\n    }\r\n\r\n    onMapClick(area) {\r\n        if (!this.areaIsSelected(area)) {\r\n            this.addAreaByStr(areaToStr(area));\r\n        }\r\n    }\r\n\r\n    areaIsSelected(area) {\r\n        if (this.state.areas && area) {\r\n          const newAreaStr = areaToStr(area);\r\n          return this.state.areas.includes(newAreaStr);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    addAreaByStr(areaStr) {\r\n        const areaObj = strToArea(areaStr);\r\n    \r\n        this.setState(\r\n          prevState => ({\r\n            areas: [...prevState.areas, areaStr]\r\n          }),\r\n          () => {\r\n            this.modelAPI.scores(\r\n            {\r\n                state: areaObj.state,\r\n                country: areaObj.country,\r\n                weeks: this.state.latestWeek,\r\n            },\r\n            data => {\r\n                this.setState(prevState => ({\r\n                mainGraphData: {\r\n                    ...prevState.mainGraphData,\r\n                    [areaStr]: data\r\n                }\r\n                }));\r\n            }\r\n            );\r\n\r\n            this.formRef.current.setFieldsValue({\r\n              areas: this.state.areas\r\n            });\r\n          }\r\n        );\r\n    }\r\n    \r\n    removeAreaByStr(targetAreaStr) {\r\n        this.setState(prevState => {\r\n          return {\r\n            // Filter out the area / graph data corresponding to the target area\r\n            // string.\r\n            areas: prevState.areas.filter(areaStr => areaStr !== targetAreaStr),\r\n            mainGraphData: Object.keys(prevState.mainGraphData)\r\n              .filter(areaStr => areaStr !== targetAreaStr)\r\n              .reduce((newMainGraphData, areaStr) => {\r\n                return {\r\n                  ...newMainGraphData,\r\n                  [areaStr]: prevState.mainGraphData[areaStr]\r\n                };\r\n              }, {})\r\n          };\r\n        });\r\n    }\r\n    \r\n    onValuesChange(changedValues, allValues) {\r\n        // If we're here it means the user either added or deleted an area, so we\r\n        // can do a union / intersection to figure out what to add/remove.\r\n        const prevAreas = this.state.areas;\r\n        const newAreas = allValues.areas;\r\n        if (newAreas && prevAreas)\r\n        {\r\n            const areasToAdd = newAreas.filter(\r\n                areaStr => !prevAreas.includes(areaStr)\r\n                );\r\n                const areasToRemove = prevAreas.filter(\r\n                areaStr => !newAreas.includes(areaStr)\r\n                );\r\n        \r\n                areasToAdd.forEach(this.addAreaByStr);\r\n                areasToRemove.forEach(this.removeAreaByStr);\r\n        }\r\n        \r\n    }\r\n\r\n    onWeeksChange(weeks) {\r\n        this.setState({ weeks }, ()=>{\r\n            if (this.state.dynamicMapOn) {\r\n                this.map.fetchData(this.state.dynamicMapOn);\r\n            }    \r\n        });\r\n    }\r\n\r\n    bindRef = ref => { \r\n        this.map = ref \r\n    }\r\n\r\n\r\n    switchDynamicMap(checked) {\r\n        this.setState({\r\n          dynamicMapOn: checked\r\n        });\r\n        this.map.fetchData(checked);\r\n    }\r\n\r\n    //when closing the alert\r\n    onAlertClose = ()=>{\r\n        this.setState({\r\n        noDataError: false\r\n        });\r\n    }\r\n\r\n    //when encounter an no data error\r\n    onNoData = (name) =>{\r\n        this.setState({\r\n        noDataError: true,\r\n        errorDescription: `There is currently no data for ${name}`\r\n        })\r\n    }\r\n\r\n    generateMarks = ()=>{\r\n        const {weeks, lastDate, latestWeek, firstDate} = this.state;\r\n        let currentDate = new Date(`${firstDate}T00:00`);\r\n        currentDate.setDate(currentDate.getDate(Date) + 7*weeks);\r\n        //get the date of the selected date on slider\r\n        let marks = {};\r\n        let i = 0;\r\n        while ( i <= 5 && weeks + i<=latestWeek)\r\n        {\r\n           marks[weeks+i] = `${currentDate.getMonth()+1}/${currentDate.getDate()}`;\r\n           currentDate.setDate(currentDate.getDate(Date) + 7);\r\n           i++;\r\n        }\r\n        i = 1\r\n        currentDate = new Date(`${firstDate}T00:00`);\r\n        currentDate.setDate(currentDate.getDate(Date) + 7*(weeks-1));\r\n        while (i <= 5 && weeks - i >= 0)\r\n        {\r\n            marks[weeks - i] = `${currentDate.getMonth()+1}/${currentDate.getDate()}`;\r\n            currentDate.setDate(currentDate.getDate(Date) - 7);\r\n            i++;\r\n        }\r\n        currentDate = new Date(`${firstDate}T00:00`);\r\n        currentDate.setDate(currentDate.getDate(Date) + 7*weeks);\r\n        return [currentDate, marks];\r\n      }\r\n\r\n    \r\n    handleScoreTypeSelect = e =>{\r\n        this.setState({\r\n            scoreType: e.target.value\r\n        }, ()=>{\r\n            const resetMap = true;\r\n            this.map.fetchData(this.state.dynamicMapOn, resetMap);\r\n        });\r\n    }\r\n\r\n    render(){\r\n        const {\r\n            areas,\r\n            areasList,\r\n            weeks,\r\n            mainGraphData,\r\n            dynamicMapOn,\r\n            latestWeek,\r\n            noDataError,\r\n            errorDescription,\r\n            scoreType\r\n          } = this.state;\r\n        const countryOptions = areasList\r\n        .filter(area => !this.areaIsSelected(area))\r\n        .map(areaToStr)\r\n        .sort()\r\n        .map(s => {\r\n        return <Option key={s}> {s} </Option>;\r\n        });\r\n\r\n        const [currentDate, marks] = this.generateMarks();\r\n        const month = (currentDate.getMonth() + 1)<10?(`0${currentDate.getMonth() + 1}`):(currentDate.getMonth() + 1);\r\n        const date = (currentDate.getDate()<10)?(`0${currentDate.getDate()}`):currentDate.getDate();\r\n        const formatted_current_date = `${month}/${date}`;\r\n        return(\r\n            <div className=\"score-page\">\r\n                <Row type=\"flex\" justify=\"space-around\">\r\n                <Col span={10}>\r\n                    {noDataError?\r\n                        <Alert\r\n                        message= {`${errorDescription}`}\r\n                        description= \"Please wait for our updates.\"\r\n                        type=\"error\"\r\n                        closable\r\n                        onClose={this.onAlertClose}\r\n                        />: null\r\n                    }\r\n                    <div className=\"form-wrapper\">\r\n                        <Form\r\n                            ref={this.formRef}\r\n                            onValuesChange={this.onValuesChange}\r\n                        >\r\n                            <Form.Item\r\n                                label=\"Areas\"\r\n                                name=\"areas\"\r\n                                rules={[{ required: true, message: \"Please select areas!\" }]}\r\n                            >\r\n                                <Select\r\n                                mode=\"multiple\"\r\n                                style={{ width: \"100%\" }}\r\n                                placeholder=\"Select Areas\"\r\n                                >\r\n                                {countryOptions}\r\n                                </Select>\r\n                            </Form.Item>\r\n\r\n                            <Form.Item\r\n                                label=\"Week to check\"\r\n                                name=\"weeks\"\r\n                                rules={[\r\n                                { required: true, message: \"Please select the week you want to see\" }\r\n                                ]}\r\n                            >\r\n                                <Slider\r\n                                    marks={marks}\r\n                                    initialValue={weeks}\r\n                                    min ={weeks-5>=0?weeks-5: 0}\r\n                                    max={weeks+5<=latestWeek?weeks+5:latestWeek}\r\n                                    onAfterChange={this.onWeeksChange}\r\n                                />\r\n                            </Form.Item>\r\n                        </Form>\r\n                        <div className=\"radio-group\">Data Type:&nbsp;&nbsp;  \r\n                            <Radio.Group\r\n                                value={scoreType}\r\n                                onChange={this.handleScoreTypeSelect}\r\n                            >\r\n                                <Radio value=\"reproduction\">Dynamic Reproduction Number</Radio>\r\n                                <Radio value=\"mfr\">Model-based Fatality Rate</Radio>\r\n                            </Radio.Group>\r\n                        </div>\r\n                        <p>\r\n                        Dynamic Map:&nbsp;&nbsp;  \r\n                        <Switch \r\n                            onChange={this.switchDynamicMap} \r\n                        />\r\n                        </p>\r\n                    </div>\r\n                </Col>\r\n                <Col span={14}>\r\n                <div className=\"map-wrapper\">\r\n                    <ScoreMap className=\"score-map\"\r\n                    triggerRef={this.bindRef}\r\n                    dynamicMapOn={dynamicMapOn}\r\n                    weeks={weeks}\r\n                    latestWeek={latestWeek}\r\n                    onMapClick={this.onMapClick} \r\n                    onNoData = {this.onNoData}\r\n                    scoreType = {scoreType}\r\n                    />\r\n                </div>\r\n                </Col>\r\n                </Row>\r\n                {areas.length?\r\n                <Row>\r\n                <Col span={24}>\r\n                    <div className=\"graph-wrapper\">\r\n                    <NewScoreGraph\r\n                        data={mainGraphData}\r\n                        date={formatted_current_date}\r\n                        scoreType={scoreType}\r\n                    ></NewScoreGraph>\r\n                    </div>\r\n                </Col>\r\n                </Row>\r\n                : null}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ScorePage;"],"sourceRoot":""}