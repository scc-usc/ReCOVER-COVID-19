{"ast":null,"code":"export default function (input, digits) {\n  if (!(0 <= (digits = +digits) && digits <= 20)) throw new Error(\"invalid digits\");\n\n  function quantizePoint(input) {\n    var n = input.length,\n        i = 2,\n        output = new Array(n);\n    output[0] = +input[0].toFixed(digits);\n    output[1] = +input[1].toFixed(digits);\n\n    while (i < n) {\n      output[i] = input[i], ++i;\n    }\n\n    return output;\n  }\n\n  function quantizePoints(input) {\n    return input.map(quantizePoint);\n  }\n\n  function quantizePointsNoDuplicates(input) {\n    var point0 = quantizePoint(input[0]);\n    var output = [point0];\n\n    for (var i = 1; i < input.length; i++) {\n      var point = quantizePoint(input[i]);\n\n      if (point.length > 2 || point[0] != point0[0] || point[1] != point0[1]) {\n        output.push(point);\n        point0 = point;\n      }\n    }\n\n    if (output.length === 1 && input.length > 1) {\n      output.push(quantizePoint(input[input.length - 1]));\n    }\n\n    return output;\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizePointsNoDuplicates);\n  }\n\n  function quantizeGeometry(input) {\n    if (input == null) return input;\n    var output;\n\n    switch (input.type) {\n      case \"GeometryCollection\":\n        output = {\n          type: \"GeometryCollection\",\n          geometries: input.geometries.map(quantizeGeometry)\n        };\n        break;\n\n      case \"Point\":\n        output = {\n          type: \"Point\",\n          coordinates: quantizePoint(input.coordinates)\n        };\n        break;\n\n      case \"MultiPoint\":\n        output = {\n          type: input.type,\n          coordinates: quantizePoints(input.coordinates)\n        };\n        break;\n\n      case \"LineString\":\n        output = {\n          type: input.type,\n          coordinates: quantizePointsNoDuplicates(input.coordinates)\n        };\n        break;\n\n      case \"MultiLineString\":\n      case \"Polygon\":\n        output = {\n          type: input.type,\n          coordinates: quantizePolygon(input.coordinates)\n        };\n        break;\n\n      case \"MultiPolygon\":\n        output = {\n          type: \"MultiPolygon\",\n          coordinates: input.coordinates.map(quantizePolygon)\n        };\n        break;\n\n      default:\n        return input;\n    }\n\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n\n  function quantizeFeature(input) {\n    var output = {\n      type: \"Feature\",\n      properties: input.properties,\n      geometry: quantizeGeometry(input.geometry)\n    };\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n\n  if (input != null) switch (input.type) {\n    case \"Feature\":\n      return quantizeFeature(input);\n\n    case \"FeatureCollection\":\n      {\n        var output = {\n          type: \"FeatureCollection\",\n          features: input.features.map(quantizeFeature)\n        };\n        if (input.bbox != null) output.bbox = input.bbox;\n        return output;\n      }\n\n    default:\n      return quantizeGeometry(input);\n  }\n  return input;\n}","map":{"version":3,"sources":["/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/d3-geo-projection/src/quantize.js"],"names":["input","digits","Error","quantizePoint","n","length","i","output","Array","toFixed","quantizePoints","map","quantizePointsNoDuplicates","point0","point","push","quantizePolygon","quantizeGeometry","type","geometries","coordinates","bbox","quantizeFeature","properties","geometry","id","features"],"mappings":"AAAA,eAAe,UAASA,KAAT,EAAgBC,MAAhB,EAAwB;AACrC,MAAI,EAAE,MAAMA,MAAM,GAAG,CAACA,MAAhB,KAA2BA,MAAM,IAAI,EAAvC,CAAJ,EAAgD,MAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;;AAEhD,WAASC,aAAT,CAAuBH,KAAvB,EAA8B;AAC5B,QAAII,CAAC,GAAGJ,KAAK,CAACK,MAAd;AAAA,QAAsBC,CAAC,GAAG,CAA1B;AAAA,QAA6BC,MAAM,GAAG,IAAIC,KAAJ,CAAUJ,CAAV,CAAtC;AACAG,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACP,KAAK,CAAC,CAAD,CAAL,CAASS,OAAT,CAAiBR,MAAjB,CAAb;AACAM,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACP,KAAK,CAAC,CAAD,CAAL,CAASS,OAAT,CAAiBR,MAAjB,CAAb;;AACA,WAAOK,CAAC,GAAGF,CAAX;AAAcG,MAAAA,MAAM,CAACD,CAAD,CAAN,GAAYN,KAAK,CAACM,CAAD,CAAjB,EAAsB,EAAEA,CAAxB;AAAd;;AACA,WAAOC,MAAP;AACD;;AAED,WAASG,cAAT,CAAwBV,KAAxB,EAA+B;AAC7B,WAAOA,KAAK,CAACW,GAAN,CAAUR,aAAV,CAAP;AACD;;AAED,WAASS,0BAAT,CAAoCZ,KAApC,EAA2C;AACzC,QAAIa,MAAM,GAAGV,aAAa,CAACH,KAAK,CAAC,CAAD,CAAN,CAA1B;AACA,QAAIO,MAAM,GAAG,CAACM,MAAD,CAAb;;AACA,SAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,KAAK,CAACK,MAA1B,EAAkCC,CAAC,EAAnC,EAAuC;AACrC,UAAIQ,KAAK,GAAGX,aAAa,CAACH,KAAK,CAACM,CAAD,CAAN,CAAzB;;AACA,UAAIQ,KAAK,CAACT,MAAN,GAAe,CAAf,IAAoBS,KAAK,CAAC,CAAD,CAAL,IAAYD,MAAM,CAAC,CAAD,CAAtC,IAA6CC,KAAK,CAAC,CAAD,CAAL,IAAYD,MAAM,CAAC,CAAD,CAAnE,EAAwE;AACtEN,QAAAA,MAAM,CAACQ,IAAP,CAAYD,KAAZ;AACAD,QAAAA,MAAM,GAAGC,KAAT;AACD;AACF;;AACD,QAAIP,MAAM,CAACF,MAAP,KAAkB,CAAlB,IAAuBL,KAAK,CAACK,MAAN,GAAe,CAA1C,EAA6C;AAC3CE,MAAAA,MAAM,CAACQ,IAAP,CAAYZ,aAAa,CAACH,KAAK,CAACA,KAAK,CAACK,MAAN,GAAe,CAAhB,CAAN,CAAzB;AACD;;AACD,WAAOE,MAAP;AACD;;AAED,WAASS,eAAT,CAAyBhB,KAAzB,EAAgC;AAC9B,WAAOA,KAAK,CAACW,GAAN,CAAUC,0BAAV,CAAP;AACD;;AAED,WAASK,gBAAT,CAA0BjB,KAA1B,EAAiC;AAC/B,QAAIA,KAAK,IAAI,IAAb,EAAmB,OAAOA,KAAP;AACnB,QAAIO,MAAJ;;AACA,YAAQP,KAAK,CAACkB,IAAd;AACE,WAAK,oBAAL;AAA2BX,QAAAA,MAAM,GAAG;AAACW,UAAAA,IAAI,EAAE,oBAAP;AAA6BC,UAAAA,UAAU,EAAEnB,KAAK,CAACmB,UAAN,CAAiBR,GAAjB,CAAqBM,gBAArB;AAAzC,SAAT;AAA2F;;AACtH,WAAK,OAAL;AAAcV,QAAAA,MAAM,GAAG;AAACW,UAAAA,IAAI,EAAE,OAAP;AAAgBE,UAAAA,WAAW,EAAEjB,aAAa,CAACH,KAAK,CAACoB,WAAP;AAA1C,SAAT;AAAyE;;AACvF,WAAK,YAAL;AAAmBb,QAAAA,MAAM,GAAG;AAACW,UAAAA,IAAI,EAAElB,KAAK,CAACkB,IAAb;AAAmBE,UAAAA,WAAW,EAAEV,cAAc,CAACV,KAAK,CAACoB,WAAP;AAA9C,SAAT;AAA6E;;AAChG,WAAK,YAAL;AAAmBb,QAAAA,MAAM,GAAG;AAACW,UAAAA,IAAI,EAAElB,KAAK,CAACkB,IAAb;AAAmBE,UAAAA,WAAW,EAAER,0BAA0B,CAACZ,KAAK,CAACoB,WAAP;AAA1D,SAAT;AAAyF;;AAC5G,WAAK,iBAAL;AAAwB,WAAK,SAAL;AAAgBb,QAAAA,MAAM,GAAG;AAACW,UAAAA,IAAI,EAAElB,KAAK,CAACkB,IAAb;AAAmBE,UAAAA,WAAW,EAAEJ,eAAe,CAAChB,KAAK,CAACoB,WAAP;AAA/C,SAAT;AAA8E;;AACtH,WAAK,cAAL;AAAqBb,QAAAA,MAAM,GAAG;AAACW,UAAAA,IAAI,EAAE,cAAP;AAAuBE,UAAAA,WAAW,EAAEpB,KAAK,CAACoB,WAAN,CAAkBT,GAAlB,CAAsBK,eAAtB;AAApC,SAAT;AAAsF;;AAC3G;AAAS,eAAOhB,KAAP;AAPX;;AASA,QAAIA,KAAK,CAACqB,IAAN,IAAc,IAAlB,EAAwBd,MAAM,CAACc,IAAP,GAAcrB,KAAK,CAACqB,IAApB;AACxB,WAAOd,MAAP;AACD;;AAED,WAASe,eAAT,CAAyBtB,KAAzB,EAAgC;AAC9B,QAAIO,MAAM,GAAG;AAACW,MAAAA,IAAI,EAAE,SAAP;AAAkBK,MAAAA,UAAU,EAAEvB,KAAK,CAACuB,UAApC;AAAgDC,MAAAA,QAAQ,EAAEP,gBAAgB,CAACjB,KAAK,CAACwB,QAAP;AAA1E,KAAb;AACA,QAAIxB,KAAK,CAACyB,EAAN,IAAY,IAAhB,EAAsBlB,MAAM,CAACkB,EAAP,GAAYzB,KAAK,CAACyB,EAAlB;AACtB,QAAIzB,KAAK,CAACqB,IAAN,IAAc,IAAlB,EAAwBd,MAAM,CAACc,IAAP,GAAcrB,KAAK,CAACqB,IAApB;AACxB,WAAOd,MAAP;AACD;;AAED,MAAIP,KAAK,IAAI,IAAb,EAAmB,QAAQA,KAAK,CAACkB,IAAd;AACjB,SAAK,SAAL;AAAgB,aAAOI,eAAe,CAACtB,KAAD,CAAtB;;AAChB,SAAK,mBAAL;AAA0B;AACxB,YAAIO,MAAM,GAAG;AAACW,UAAAA,IAAI,EAAE,mBAAP;AAA4BQ,UAAAA,QAAQ,EAAE1B,KAAK,CAAC0B,QAAN,CAAef,GAAf,CAAmBW,eAAnB;AAAtC,SAAb;AACA,YAAItB,KAAK,CAACqB,IAAN,IAAc,IAAlB,EAAwBd,MAAM,CAACc,IAAP,GAAcrB,KAAK,CAACqB,IAApB;AACxB,eAAOd,MAAP;AACD;;AACD;AAAS,aAAOU,gBAAgB,CAACjB,KAAD,CAAvB;AAPQ;AAUnB,SAAOA,KAAP;AACD","sourcesContent":["export default function(input, digits) {\n  if (!(0 <= (digits = +digits) && digits <= 20)) throw new Error(\"invalid digits\");\n\n  function quantizePoint(input) {\n    var n = input.length, i = 2, output = new Array(n);\n    output[0] = +input[0].toFixed(digits);\n    output[1] = +input[1].toFixed(digits);\n    while (i < n) output[i] = input[i], ++i;\n    return output;\n  }\n\n  function quantizePoints(input) {\n    return input.map(quantizePoint);\n  }\n\n  function quantizePointsNoDuplicates(input) {\n    var point0 = quantizePoint(input[0]);\n    var output = [point0];\n    for (var i = 1; i < input.length; i++) {\n      var point = quantizePoint(input[i]);\n      if (point.length > 2 || point[0] != point0[0] || point[1] != point0[1]) {\n        output.push(point);\n        point0 = point;\n      }\n    }\n    if (output.length === 1 && input.length > 1) {\n      output.push(quantizePoint(input[input.length - 1]));\n    }\n    return output;\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizePointsNoDuplicates);\n  }\n\n  function quantizeGeometry(input) {\n    if (input == null) return input;\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: input.type, coordinates: quantizePoints(input.coordinates)}; break;\n      case \"LineString\": output = {type: input.type, coordinates: quantizePointsNoDuplicates(input.coordinates)}; break;\n      case \"MultiLineString\": case \"Polygon\": output = {type: input.type, coordinates: quantizePolygon(input.coordinates)}; break;\n      case \"MultiPolygon\": output = {type: \"MultiPolygon\", coordinates: input.coordinates.map(quantizePolygon)}; break;\n      default: return input;\n    }\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n\n  function quantizeFeature(input) {\n    var output = {type: \"Feature\", properties: input.properties, geometry: quantizeGeometry(input.geometry)};\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n\n  if (input != null) switch (input.type) {\n    case \"Feature\": return quantizeFeature(input);\n    case \"FeatureCollection\": {\n      var output = {type: \"FeatureCollection\", features: input.features.map(quantizeFeature)};\n      if (input.bbox != null) output.bbox = input.bbox;\n      return output;\n    }\n    default: return quantizeGeometry(input);\n  }\n\n  return input;\n}\n"]},"metadata":{},"sourceType":"module"}