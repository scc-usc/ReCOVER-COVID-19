{"ast":null,"code":"import { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { abs, acos, asin, atan2, cos, epsilon2, halfPi, pi, sin, sqrt } from \"./math.js\";\nexport function hillRaw(K) {\n  var L = 1 + K,\n      sinBt = sin(1 / L),\n      Bt = asin(sinBt),\n      A = 2 * sqrt(pi / (B = pi + 4 * Bt * L)),\n      B,\n      rho0 = 0.5 * A * (L + sqrt(K * (2 + K))),\n      K2 = K * K,\n      L2 = L * L;\n\n  function forward(lambda, phi) {\n    var t = 1 - sin(phi),\n        rho,\n        omega;\n\n    if (t && t < 2) {\n      var theta = halfPi - phi,\n          i = 25,\n          delta;\n\n      do {\n        var sinTheta = sin(theta),\n            cosTheta = cos(theta),\n            Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta),\n            C = 1 + L2 - 2 * L * cosTheta;\n        theta -= delta = (theta - K2 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B) / (2 * L * sinTheta * Bt_Bt1);\n      } while (abs(delta) > epsilon2 && --i > 0);\n\n      rho = A * sqrt(C);\n      omega = lambda * Bt_Bt1 / pi;\n    } else {\n      rho = A * (K + t);\n      omega = lambda * Bt / pi;\n    }\n\n    return [rho * sin(omega), rho0 - rho * cos(omega)];\n  }\n\n  forward.invert = function (x, y) {\n    var rho2 = x * x + (y -= rho0) * y,\n        cosTheta = (1 + L2 - rho2 / (A * A)) / (2 * L),\n        theta = acos(cosTheta),\n        sinTheta = sin(theta),\n        Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta);\n    return [asin(x / sqrt(rho2)) * pi / Bt_Bt1, asin(1 - 2 * (theta - K2 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B)];\n  };\n\n  return forward;\n}\nexport default function () {\n  var K = 1,\n      m = projectionMutator(hillRaw),\n      p = m(K);\n\n  p.ratio = function (_) {\n    return arguments.length ? m(K = +_) : K;\n  };\n\n  return p.scale(167.774).center([0, 18.67]);\n}","map":{"version":3,"sources":["/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/d3-geo-projection/src/hill.js"],"names":["geoProjectionMutator","projectionMutator","abs","acos","asin","atan2","cos","epsilon2","halfPi","pi","sin","sqrt","hillRaw","K","L","sinBt","Bt","A","B","rho0","K2","L2","forward","lambda","phi","t","rho","omega","theta","i","delta","sinTheta","cosTheta","Bt_Bt1","C","invert","x","y","rho2","m","p","ratio","_","arguments","length","scale","center"],"mappings":"AAAA,SAAQA,oBAAoB,IAAIC,iBAAhC,QAAwD,QAAxD;AACA,SAAQC,GAAR,EAAaC,IAAb,EAAmBC,IAAnB,EAAyBC,KAAzB,EAAgCC,GAAhC,EAAqCC,QAArC,EAA+CC,MAA/C,EAAuDC,EAAvD,EAA2DC,GAA3D,EAAgEC,IAAhE,QAA2E,WAA3E;AAEA,OAAO,SAASC,OAAT,CAAiBC,CAAjB,EAAoB;AACzB,MAAIC,CAAC,GAAG,IAAID,CAAZ;AAAA,MACIE,KAAK,GAAGL,GAAG,CAAC,IAAII,CAAL,CADf;AAAA,MAEIE,EAAE,GAAGZ,IAAI,CAACW,KAAD,CAFb;AAAA,MAGIE,CAAC,GAAG,IAAIN,IAAI,CAACF,EAAE,IAAIS,CAAC,GAAGT,EAAE,GAAG,IAAIO,EAAJ,GAASF,CAAtB,CAAH,CAHhB;AAAA,MAIII,CAJJ;AAAA,MAKIC,IAAI,GAAG,MAAMF,CAAN,IAAWH,CAAC,GAAGH,IAAI,CAACE,CAAC,IAAI,IAAIA,CAAR,CAAF,CAAnB,CALX;AAAA,MAMIO,EAAE,GAAGP,CAAC,GAAGA,CANb;AAAA,MAOIQ,EAAE,GAAGP,CAAC,GAAGA,CAPb;;AASA,WAASQ,OAAT,CAAiBC,MAAjB,EAAyBC,GAAzB,EAA8B;AAC5B,QAAIC,CAAC,GAAG,IAAIf,GAAG,CAACc,GAAD,CAAf;AAAA,QACIE,GADJ;AAAA,QAEIC,KAFJ;;AAGA,QAAIF,CAAC,IAAIA,CAAC,GAAG,CAAb,EAAgB;AACd,UAAIG,KAAK,GAAGpB,MAAM,GAAGgB,GAArB;AAAA,UAA0BK,CAAC,GAAG,EAA9B;AAAA,UAAkCC,KAAlC;;AACA,SAAG;AACD,YAAIC,QAAQ,GAAGrB,GAAG,CAACkB,KAAD,CAAlB;AAAA,YACII,QAAQ,GAAG1B,GAAG,CAACsB,KAAD,CADlB;AAAA,YAEIK,MAAM,GAAGjB,EAAE,GAAGX,KAAK,CAAC0B,QAAD,EAAWjB,CAAC,GAAGkB,QAAf,CAFvB;AAAA,YAGIE,CAAC,GAAG,IAAIb,EAAJ,GAAS,IAAIP,CAAJ,GAAQkB,QAHzB;AAIAJ,QAAAA,KAAK,IAAIE,KAAK,GAAG,CAACF,KAAK,GAAGR,EAAE,GAAGJ,EAAb,GAAkBF,CAAC,GAAGiB,QAAtB,GAAiCG,CAAC,GAAGD,MAArC,GAA6C,MAAMR,CAAN,GAAUP,CAAxD,KAA8D,IAAIJ,CAAJ,GAAQiB,QAAR,GAAmBE,MAAjF,CAAjB;AACD,OAND,QAMS/B,GAAG,CAAC4B,KAAD,CAAH,GAAavB,QAAb,IAAyB,EAAEsB,CAAF,GAAM,CANxC;;AAOAH,MAAAA,GAAG,GAAGT,CAAC,GAAGN,IAAI,CAACuB,CAAD,CAAd;AACAP,MAAAA,KAAK,GAAGJ,MAAM,GAAGU,MAAT,GAAkBxB,EAA1B;AACD,KAXD,MAWO;AACLiB,MAAAA,GAAG,GAAGT,CAAC,IAAIJ,CAAC,GAAGY,CAAR,CAAP;AACAE,MAAAA,KAAK,GAAGJ,MAAM,GAAGP,EAAT,GAAcP,EAAtB;AACD;;AACD,WAAO,CACLiB,GAAG,GAAGhB,GAAG,CAACiB,KAAD,CADJ,EAELR,IAAI,GAAGO,GAAG,GAAGpB,GAAG,CAACqB,KAAD,CAFX,CAAP;AAID;;AAEDL,EAAAA,OAAO,CAACa,MAAR,GAAiB,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAC9B,QAAIC,IAAI,GAAGF,CAAC,GAAGA,CAAJ,GAAQ,CAACC,CAAC,IAAIlB,IAAN,IAAckB,CAAjC;AAAA,QACIL,QAAQ,GAAG,CAAC,IAAIX,EAAJ,GAASiB,IAAI,IAAIrB,CAAC,GAAGA,CAAR,CAAd,KAA6B,IAAIH,CAAjC,CADf;AAAA,QAEIc,KAAK,GAAGzB,IAAI,CAAC6B,QAAD,CAFhB;AAAA,QAGID,QAAQ,GAAGrB,GAAG,CAACkB,KAAD,CAHlB;AAAA,QAIIK,MAAM,GAAGjB,EAAE,GAAGX,KAAK,CAAC0B,QAAD,EAAWjB,CAAC,GAAGkB,QAAf,CAJvB;AAKA,WAAO,CACL5B,IAAI,CAACgC,CAAC,GAAGzB,IAAI,CAAC2B,IAAD,CAAT,CAAJ,GAAuB7B,EAAvB,GAA4BwB,MADvB,EAEL7B,IAAI,CAAC,IAAI,KAAKwB,KAAK,GAAGR,EAAE,GAAGJ,EAAb,GAAkBF,CAAC,GAAGiB,QAAtB,GAAiC,CAAC,IAAIV,EAAJ,GAAS,IAAIP,CAAJ,GAAQkB,QAAlB,IAA8BC,MAApE,IAA8Ef,CAAnF,CAFC,CAAP;AAID,GAVD;;AAYA,SAAOI,OAAP;AACD;AAED,eAAe,YAAW;AACxB,MAAIT,CAAC,GAAG,CAAR;AAAA,MACI0B,CAAC,GAAGtC,iBAAiB,CAACW,OAAD,CADzB;AAAA,MAEI4B,CAAC,GAAGD,CAAC,CAAC1B,CAAD,CAFT;;AAIA2B,EAAAA,CAAC,CAACC,KAAF,GAAU,UAASC,CAAT,EAAY;AACpB,WAAOC,SAAS,CAACC,MAAV,GAAmBL,CAAC,CAAC1B,CAAC,GAAG,CAAC6B,CAAN,CAApB,GAA+B7B,CAAtC;AACD,GAFD;;AAIA,SAAO2B,CAAC,CACHK,KADE,CACI,OADJ,EAEFC,MAFE,CAEK,CAAC,CAAD,EAAI,KAAJ,CAFL,CAAP;AAGD","sourcesContent":["import {geoProjectionMutator as projectionMutator} from \"d3-geo\";\nimport {abs, acos, asin, atan2, cos, epsilon2, halfPi, pi, sin, sqrt} from \"./math.js\";\n\nexport function hillRaw(K) {\n  var L = 1 + K,\n      sinBt = sin(1 / L),\n      Bt = asin(sinBt),\n      A = 2 * sqrt(pi / (B = pi + 4 * Bt * L)),\n      B,\n      rho0 = 0.5 * A * (L + sqrt(K * (2 + K))),\n      K2 = K * K,\n      L2 = L * L;\n\n  function forward(lambda, phi) {\n    var t = 1 - sin(phi),\n        rho,\n        omega;\n    if (t && t < 2) {\n      var theta = halfPi - phi, i = 25, delta;\n      do {\n        var sinTheta = sin(theta),\n            cosTheta = cos(theta),\n            Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta),\n            C = 1 + L2 - 2 * L * cosTheta;\n        theta -= delta = (theta - K2 * Bt - L * sinTheta + C * Bt_Bt1 -0.5 * t * B) / (2 * L * sinTheta * Bt_Bt1);\n      } while (abs(delta) > epsilon2 && --i > 0);\n      rho = A * sqrt(C);\n      omega = lambda * Bt_Bt1 / pi;\n    } else {\n      rho = A * (K + t);\n      omega = lambda * Bt / pi;\n    }\n    return [\n      rho * sin(omega),\n      rho0 - rho * cos(omega)\n    ];\n  }\n\n  forward.invert = function(x, y) {\n    var rho2 = x * x + (y -= rho0) * y,\n        cosTheta = (1 + L2 - rho2 / (A * A)) / (2 * L),\n        theta = acos(cosTheta),\n        sinTheta = sin(theta),\n        Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta);\n    return [\n      asin(x / sqrt(rho2)) * pi / Bt_Bt1,\n      asin(1 - 2 * (theta - K2 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B)\n    ];\n  };\n\n  return forward;\n}\n\nexport default function() {\n  var K = 1,\n      m = projectionMutator(hillRaw),\n      p = m(K);\n\n  p.ratio = function(_) {\n    return arguments.length ? m(K = +_) : K;\n  };\n\n  return p\n      .scale(167.774)\n      .center([0, 18.67]);\n}\n"]},"metadata":{},"sourceType":"module"}