{"ast":null,"code":"/**\r\n * Map line module\r\n */\nimport { __extends, __values } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { MapObject } from \"./MapObject\";\nimport { MapLineObject } from \"./MapLineObject\";\nimport { MapImage } from \"./MapImage\";\nimport { MapImageSeries } from \"./MapImageSeries\";\nimport { Triangle } from \"../../core/elements/Triangle\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { Polyline } from \"../../core/elements/Polyline\";\nimport { registry } from \"../../core/Registry\";\nimport { color } from \"../../core/utils/Color\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport { percent, Percent } from \"../../core/utils/Percent\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $geo from \"./Geo\";\nimport * as $mapUtils from \"./MapUtils\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to draw a line on the map.\r\n *\r\n * @see {@link IMapLineEvents} for a list of available events\r\n * @see {@link IMapLineAdapters} for a list of available Adapters\r\n */\n\nvar MapLine =\n/** @class */\nfunction (_super) {\n  __extends(MapLine, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapLine() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A list of event disposers for images.\r\n     */\n\n\n    _this._imageListeners = {};\n    _this.className = \"MapLine\";\n\n    _this.createLine();\n\n    _this.line.stroke = color();\n    _this.line.parent = _this;\n    _this.strokeOpacity = 1;\n\n    _this.setPropertyValue(\"precision\", 0.1);\n\n    var interfaceColors = new InterfaceColorSet();\n    _this.stroke = interfaceColors.getFor(\"grid\");\n    _this.shortestDistance = true; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapLine.prototype.createLine = function () {\n    this.line = new Polyline();\n  };\n  /**\r\n   * Converts a position within the line (0-1) to a physical point\r\n   * coordinates.\r\n   *\r\n   * 0 indicates start of the line, 0.5 - middle, while 1 indicates the end.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n\n\n  MapLine.prototype.positionToPoint = function (position) {\n    if (this.shortestDistance) {\n      return this.series.chart.projection.positionToPoint(this.multiGeoLine, position);\n    } else {\n      if (this.line) {\n        return this.line.positionToPoint(position);\n      }\n    }\n\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  };\n\n  Object.defineProperty(MapLine.prototype, \"multiGeoLine\", {\n    /**\r\n     * @return Coordinates\r\n     */\n    get: function get() {\n      var multiGeoLine = this.getPropertyValue(\"multiGeoLine\");\n\n      if (!multiGeoLine && this.dataItem && this.dataItem.multiGeoLine) {\n        multiGeoLine = this.dataItem.multiGeoLine;\n      }\n\n      return multiGeoLine;\n    },\n\n    /**\r\n     * A collection of X/Y coordinates for a multi-segment line. E.g.:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   // Segment 1\r\n     *   [\r\n     *     { longitude: 3.121, latitude: 0.58 },\r\n     *     { longitude: -5.199, latitude: 21.223 }\r\n     *   ],\r\n     *\r\n     *   // Segment 2\r\n     *   [\r\n     *     { longitude: -5.199, latitude: 21.223 },\r\n     *     { longitude: -12.9, latitude: 25.85 }\r\n     *   ]\r\n     * ]\r\n     * ```\r\n     *\r\n     * @see {@link https://tools.ietf.org/html/rfc7946#section-3.1.5} GeoJSON MultiLineString reference\r\n     * @param multiGeoLine  Coordinates\r\n     */\n    set: function set(multiGeoLine) {\n      if (multiGeoLine && multiGeoLine.length > 0) {\n        this.setPropertyValue(\"multiGeoLine\", $geo.normalizeMultiline(multiGeoLine), true);\n        var multiLine = $mapUtils.multiGeoLineToMultiLine(multiGeoLine);\n        this.setPropertyValue(\"multiLine\", multiLine);\n        this.updateExtremes();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapLine.prototype, \"multiLine\", {\n    /**\r\n     * @return Coordinates\r\n     */\n    get: function get() {\n      var multiLine = this.getPropertyValue(\"multiLine\");\n\n      if (!multiLine && this.dataItem && this.dataItem.multiLine) {\n        multiLine = this.dataItem.multiLine;\n      }\n\n      return multiLine;\n    },\n\n    /**\r\n     * A collection of X/Y coordinates for a multi-segment line. E.g.:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   // Segment 1\r\n     *   [\r\n     *     [ 100, 150 ],\r\n     *     [ 120, 200 ]\r\n     *   ],\r\n     *\r\n     *   // Segment 2\r\n     *   [\r\n     *     [ 120, 200 ],\r\n     *     [ 150, 100 ]\r\n     *   ]\r\n     * ]\r\n     * ```\r\n     *\r\n     * @param multiLine  Coordinates\r\n     */\n    set: function set(multiLine) {\n      this.setPropertyValue(\"multiLine\", multiLine);\n      this.multiGeoLine = $mapUtils.multiLineToGeo(multiLine);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapLine.prototype, \"imagesToConnect\", {\n    /**\r\n     * @return {MapImages[]}\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"imagesToConnect\");\n    },\n\n    /**\r\n     * Instead of setting longitudes/latitudes you can set an array of images\r\n     * which will be connected by the line.\r\n     *\r\n     * Parameter is an array that can hold string `id`'s to of the images, or\r\n     * references to actual [[MapImage]] objects.\r\n     *\r\n     * @param images  Images\r\n     */\n    set: function set(images) {\n      var _this = this;\n\n      this.setPropertyValue(\"imagesToConnect\", images, true);\n      this.handleImagesToConnect();\n\n      if (this.series) {\n        var chart = this.series.chart;\n\n        if (chart) {\n          chart.series.each(function (series) {\n            if (series instanceof MapImageSeries) {\n              if (!series.isReady()) {\n                _this._disposers.push(series.events.on(\"ready\", _this.handleImagesToConnect, _this, false));\n              }\n            }\n          });\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MapLine.prototype.handleImagesToConnect = function () {\n    var e_1, _a;\n\n    var _this = this;\n\n    if (this.imagesToConnect) {\n      var segment = [];\n      var multiGeoLine = [segment];\n\n      var _loop_1 = function _loop_1(image) {\n        if ($type.isString(image)) {\n          var chart = this_1.series.chart;\n\n          if (chart) {\n            chart.series.each(function (series) {\n              if (series instanceof MapImageSeries) {\n                var img = series.getImageById(image);\n\n                if (img) {\n                  image = img;\n                }\n              }\n            });\n          }\n        }\n\n        if (image instanceof MapImage) {\n          segment.push({\n            longitude: image.longitude,\n            latitude: image.latitude\n          });\n\n          if (!this_1._imageListeners[image.uid]) {\n            var disposer = image.events.on(\"propertychanged\", function (event) {\n              if (event.property == \"longitude\" || event.property == \"latitude\") {\n                _this.handleImagesToConnect();\n\n                _this.invalidate();\n              }\n            }, this_1, false);\n            this_1._imageListeners[image.uid] = disposer;\n\n            this_1._disposers.push(disposer);\n          }\n        }\n      };\n\n      var this_1 = this;\n\n      try {\n        for (var _b = __values(this.imagesToConnect), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var image = _c.value;\n\n          _loop_1(image);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      this.multiGeoLine = multiGeoLine;\n    }\n  };\n  /**\r\n   * (Re)validates the line, effectively forcing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapLine.prototype.validate = function () {\n    var chart = this.series.chart;\n\n    if (this.multiLine) {\n      if (!this.shortestDistance) {\n        var convertedPoints = [];\n\n        for (var i = 0, len = this.multiLine.length; i < len; i++) {\n          var segment = this.multiLine[i];\n          var convertedSegmentPoints = [];\n\n          for (var s = 0, slen = segment.length; s < slen; s++) {\n            var geoPoint = segment[s];\n            var point = this.series.chart.projection.convert({\n              longitude: geoPoint[0],\n              latitude: geoPoint[1]\n            });\n            convertedSegmentPoints.push(point);\n          }\n\n          convertedPoints.push(convertedSegmentPoints);\n        }\n\n        this.line.segments = convertedPoints;\n      } else {\n        chart.projection.d3Projection.precision(this.precision);\n        this.line.path = chart.projection.d3Path(this.getFeature());\n      }\n\n      if (this._arrow) {\n        this._arrow.validatePosition();\n      }\n\n      $iter.each(this.lineObjects.iterator(), function (x) {\n        x.validatePosition();\n      });\n      this.handleGlobalScale();\n    } else if (this.imagesToConnect) {\n      this.handleImagesToConnect();\n    }\n\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapLine.prototype.getFeature = function () {\n    if (this.multiLine && this.multiLine.length > 0 && this.multiLine[0] && this.multiLine[0].length > 0) {\n      return {\n        \"type\": \"Feature\",\n        geometry: {\n          type: \"MultiLineString\",\n          coordinates: this.multiLine\n        }\n      };\n    }\n  };\n  /**\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapLine.prototype.measureElement = function () {// Overriding, just to avoid extra measure\n  };\n\n  Object.defineProperty(MapLine.prototype, \"shortestDistance\", {\n    /**\r\n     * @return Real path?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"shortestDistance\");\n    },\n\n    /**\r\n     * The line should take the shortest path over the globe.\r\n     *\r\n     * Enabling this will make the line look differently in different\r\n     * projections. Only `MapLine` supports this setting, `MapArc` and\r\n     * `MapSplice` don't.\r\n     *\r\n     * @default true\r\n     * @param value  Real path?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"shortestDistance\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapLine.prototype, \"lineObjects\", {\n    /**\r\n     * List of separate line objects the line consists of.\r\n     *\r\n     * @readonly\r\n     * @return List of line objects\r\n     */\n    get: function get() {\n      if (!this._lineObjects) {\n        this._lineObjects = new ListTemplate(new MapLineObject());\n\n        this._lineObjects.events.on(\"inserted\", this.handleLineObjectAdded, this, false);\n\n        this._disposers.push(new ListDisposer(this._lineObjects));\n\n        this._disposers.push(this._lineObjects.template);\n      }\n\n      return this._lineObjects;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Decorate a [[LineObject]] when it is added to the line.\r\n   *\r\n   * @param event  Event\r\n   */\n\n  MapLine.prototype.handleLineObjectAdded = function (event) {\n    var mapLineObject = event.newValue;\n    mapLineObject.mapLine = this;\n    mapLineObject.shouldClone = false;\n    mapLineObject.parent = this;\n  };\n\n  Object.defineProperty(MapLine.prototype, \"arrow\", {\n    /**\r\n     * @return Arrow element\r\n     */\n    get: function get() {\n      if (!this._arrow) {\n        var arrow = this.createChild(MapLineObject);\n        arrow.shouldClone = false;\n        arrow.width = 8;\n        arrow.height = 10;\n        arrow.mapLine = this;\n        arrow.position = 0.5;\n        var triangle = arrow.createChild(Triangle); //triangle.shouldClone = false;\n\n        triangle.fillOpacity = 1;\n        triangle.width = percent(100);\n        triangle.height = percent(100);\n        triangle.rotation = 90;\n        triangle.horizontalCenter = \"middle\";\n        triangle.verticalCenter = \"middle\";\n        this._arrow = arrow;\n      }\n\n      return this._arrow;\n    },\n\n    /**\r\n     * A [[MapLineObject]] to use as an option arrowhead on the line.\r\n     *\r\n     * Just accessing this property will create a default arrowhead on the line\r\n     * automatically.\r\n     *\r\n     * @param arrow  Arrow element\r\n     */\n    set: function set(arrow) {\n      this._arrow = arrow;\n      arrow.mapLine = this;\n      arrow.parent = this;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies line properties and other attributes, like arrow, from another\r\n   * instance of [[MapLine]].\r\n   *\r\n   * @param source  Source map line\r\n   */\n\n  MapLine.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.line.copyFrom(source.line);\n    this.lineObjects.copyFrom(source.lineObjects);\n\n    if (source._arrow) {\n      this.arrow = source.arrow.clone();\n    }\n  };\n\n  Object.defineProperty(MapLine.prototype, \"latitude\", {\n    /**\r\n     * Latitude of the line center.\r\n     *\r\n     * @readonly\r\n     * @return Latitude\r\n     */\n    get: function get() {\n      return this.north + (this.south - this.north) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapLine.prototype, \"longitude\", {\n    /**\r\n     * Longitude of the line center.\r\n     *\r\n     * @readonly\r\n     * @return Latitude\r\n     */\n    get: function get() {\n      return this.east + (this.west - this.east) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * X coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return X\r\n   */\n\n  MapLine.prototype.getTooltipX = function () {\n    var x = this.getPropertyValue(\"tooltipX\");\n\n    if (!(x instanceof Percent)) {\n      x = percent(50);\n    }\n\n    if (x instanceof Percent) {\n      return this.positionToPoint(x.value).x;\n    } else {\n      return 0;\n    }\n  };\n  /**\r\n   * Y coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return Y\r\n   */\n\n\n  MapLine.prototype.getTooltipY = function () {\n    var y = this.getPropertyValue(\"tooltipY\");\n\n    if (!(y instanceof Percent)) {\n      y = percent(50);\n    }\n\n    if (y instanceof Percent) {\n      return this.positionToPoint(y.value).y;\n    } else {\n      return 0;\n    }\n  };\n\n  Object.defineProperty(MapLine.prototype, \"precision\", {\n    /**\r\n     * @return Precision\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"precision\");\n    },\n\n    /**\r\n     * When line is plotted, if its `shortestDistance` is set to `true` it is\r\n     * bent according to the used projection, to depict the shortest distance how\r\n     * it would go on the actual land.\r\n     *\r\n     * `precision` introduces a setting which can control when such bending\r\n     * occurs.\r\n     *\r\n     * If the distance (in degrees) between line start and end points\r\n     * is less than `precision`, no bending will take place and the line will be\r\n     * straight.\r\n     *\r\n     * Set to large number (e.g. 10000) for perfectly straight line.\r\n     *\r\n     * @since 4.9.1\r\n     * @default 0.1\r\n     * @param  value  Precision\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"precision\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return MapLine;\n}(MapObject);\n\nexport { MapLine };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"MapLine\"] = MapLine;","map":{"version":3,"sources":["../../../../../src/.internal/charts/map/MapLine.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Map line module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapObject, IMapObjectProperties, IMapObjectAdapters, IMapObjectEvents } from \"./MapObject\";\r\nimport { MapLineObject } from \"./MapLineObject\";\r\nimport { MapLineSeriesDataItem, MapLineSeries } from \"./MapLineSeries\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { MapImage } from \"./MapImage\";\r\nimport { MapImageSeries } from \"./MapImageSeries\";\r\nimport { IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { Triangle } from \"../../core/elements/Triangle\";\r\nimport { ListTemplate, IListEvents, ListDisposer } from \"../../core/utils/List\";\r\nimport { Polyline } from \"../../core/elements/Polyline\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport { percent, Percent } from \"../../core/utils/Percent\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport { IDisposer } from \"../../core/utils/Disposer\";\r\nimport * as $geo from \"./Geo\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\n\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapLine]].\r\n */\r\nexport interface IMapLineProperties extends IMapObjectProperties {\r\n\r\n\t/**\r\n\t * Lat/long coordinates of all line ends and intermediate elbows.\r\n\t */\r\n\tmultiGeoLine?: Array<Array<IGeoPoint>>;\r\n\r\n\t/**\r\n\t * Lat/long coordinates of all line ends and intermediate elbows.\r\n\t */\r\n\tmultiLine?: Array<Array<[number, number]>>;\r\n\r\n\t/**\r\n\t * If `true` it line will be arched in the way to simulate shortest path\r\n\t * over curvature of Earth's surface, based on currently used on projection.\r\n\t */\r\n\tshortestDistance?: boolean;\r\n\r\n\t/**\r\n\t * Instead of setting longitudes/latitudes you can set an array of images which will be connected by the line\r\n\t */\r\n\timagesToConnect?: MapImage[];\r\n\r\n\t/**\r\n\t * When line is plotted, if its `shortestDistance` is set to `true` it is\r\n\t * bent according to the used projection, to depict the shortest distance how\r\n\t * it would go on the actual land.\r\n\t *\r\n\t * `precision` introduces a setting which can control when such bending\r\n\t * occurs.\r\n\t *\r\n\t * If the distance (in degrees) between line start and end points\r\n\t * is less than `precision`, no bending will take place and the line will be\r\n\t * straight.\r\n\t *\r\n\t * Set to large number (e.g. 10000) for perfectly straight line.\r\n\t *\r\n\t * @since 4.9.1\r\n\t * @default 0.1\r\n\t */\r\n\tprecision?: number;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[MapLine]].\r\n */\r\nexport interface IMapLineEvents extends IMapObjectEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapLine]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapLineAdapters extends IMapObjectAdapters, IMapLineProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to draw a line on the map.\r\n *\r\n * @see {@link IMapLineEvents} for a list of available events\r\n * @see {@link IMapLineAdapters} for a list of available Adapters\r\n */\r\nexport class MapLine extends MapObject {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IMapLineProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IMapLineAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IMapLineEvents;\r\n\r\n\t/**\r\n\t * A line visual element.\r\n\t */\r\n\tpublic line: Polyline;\r\n\r\n\t/**\r\n\t * A list of actual line objects.\r\n\t */\r\n\tprotected _lineObjects: ListTemplate<MapLineObject>;\r\n\r\n\t/**\r\n\t * A reference to arrow object.\r\n\t */\r\n\tprotected _arrow: MapLineObject;\r\n\r\n\t/**\r\n\t * Related data item.\r\n\t */\r\n\tpublic _dataItem: MapLineSeriesDataItem;\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t */\r\n\tpublic series: MapLineSeries;\r\n\r\n\t/**\r\n\t * Instead of setting longitudes/latitudes you can set an array of images\r\n\t * which will be connected by the line.\r\n\t */\r\n\tprotected _imagesToConnect: MapImage[];\r\n\r\n\t/**\r\n\t * A list of event disposers for images.\r\n\t */\r\n\tprotected _imageListeners: { [index: string]: IDisposer } = {};\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapLine\";\r\n\r\n\t\tthis.createLine();\r\n\t\tthis.line.stroke = color();\r\n\t\tthis.line.parent = this;\r\n\t\tthis.strokeOpacity = 1;\r\n\t\tthis.setPropertyValue(\"precision\", 0.1);\r\n\r\n\t\tlet interfaceColors = new InterfaceColorSet();\r\n\r\n\t\tthis.stroke = interfaceColors.getFor(\"grid\");\r\n\t\tthis.shortestDistance = true;\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected createLine() {\r\n\t\tthis.line = new Polyline();\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a position within the line (0-1) to a physical point\r\n\t * coordinates.\r\n\t *\r\n\t * 0 indicates start of the line, 0.5 - middle, while 1 indicates the end.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic positionToPoint(position: number): IOrientationPoint {\r\n\t\tif (this.shortestDistance) {\r\n\t\t\treturn this.series.chart.projection.positionToPoint(this.multiGeoLine, position);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this.line) {\r\n\t\t\t\treturn this.line.positionToPoint(position);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn { x: 0, y: 0, angle: 0 };\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-segment line. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   // Segment 1\r\n\t *   [\r\n\t *     { longitude: 3.121, latitude: 0.58 },\r\n\t *     { longitude: -5.199, latitude: 21.223 }\r\n\t *   ],\r\n\t *\r\n\t *   // Segment 2\r\n\t *   [\r\n\t *     { longitude: -5.199, latitude: 21.223 },\r\n\t *     { longitude: -12.9, latitude: 25.85 }\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://tools.ietf.org/html/rfc7946#section-3.1.5} GeoJSON MultiLineString reference\r\n\t * @param multiGeoLine  Coordinates\r\n\t */\r\n\tpublic set multiGeoLine(multiGeoLine: Array<Array<IGeoPoint>>) {\r\n\t\tif (multiGeoLine && multiGeoLine.length > 0) {\r\n\t\t\tthis.setPropertyValue(\"multiGeoLine\", $geo.normalizeMultiline(multiGeoLine), true);\r\n\r\n\t\t\tlet multiLine: Array<Array<[number, number]>> = $mapUtils.multiGeoLineToMultiLine(multiGeoLine);\r\n\r\n\t\t\tthis.setPropertyValue(\"multiLine\", multiLine);\r\n\r\n\t\t\tthis.updateExtremes();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic get multiGeoLine(): Array<Array<IGeoPoint>> {\r\n\t\tlet multiGeoLine = this.getPropertyValue(\"multiGeoLine\");\r\n\t\tif (!multiGeoLine && this.dataItem && this.dataItem.multiGeoLine) {\r\n\t\t\tmultiGeoLine = this.dataItem.multiGeoLine;\r\n\t\t}\r\n\r\n\t\treturn multiGeoLine;\r\n\t}\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-segment line. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   // Segment 1\r\n\t *   [\r\n\t *     [ 100, 150 ],\r\n\t *     [ 120, 200 ]\r\n\t *   ],\r\n\t *\r\n\t *   // Segment 2\r\n\t *   [\r\n\t *     [ 120, 200 ],\r\n\t *     [ 150, 100 ]\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * @param multiLine  Coordinates\r\n\t */\r\n\tpublic set multiLine(multiLine: Array<Array<[number, number]>>) {\r\n\t\tthis.setPropertyValue(\"multiLine\", multiLine);\r\n\t\tthis.multiGeoLine = $mapUtils.multiLineToGeo(multiLine);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic get multiLine(): Array<Array<[number, number]>> {\r\n\r\n\t\tlet multiLine = this.getPropertyValue(\"multiLine\");\r\n\t\tif (!multiLine && this.dataItem && this.dataItem.multiLine) {\r\n\t\t\tmultiLine = this.dataItem.multiLine;\r\n\t\t}\r\n\r\n\t\treturn multiLine;\r\n\t}\r\n\r\n\t/**\r\n\t * Instead of setting longitudes/latitudes you can set an array of images\r\n\t * which will be connected by the line.\r\n\t *\r\n\t * Parameter is an array that can hold string `id`'s to of the images, or\r\n\t * references to actual [[MapImage]] objects.\r\n\t *\r\n\t * @param images  Images\r\n\t */\r\n\tpublic set imagesToConnect(images: MapImage[] | string[]) {\r\n\t\tthis.setPropertyValue(\"imagesToConnect\", images, true);\r\n\t\tthis.handleImagesToConnect();\r\n\r\n\t\tif (this.series) {\r\n\t\t\tlet chart = this.series.chart;\r\n\t\t\tif (chart) {\r\n\t\t\t\tchart.series.each((series) => {\r\n\t\t\t\t\tif (series instanceof MapImageSeries) {\r\n\t\t\t\t\t\tif (!series.isReady()) {\r\n\t\t\t\t\t\t\tthis._disposers.push(series.events.on(\"ready\", this.handleImagesToConnect, this, false));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return {MapImages[]}\r\n\t */\r\n\tpublic get imagesToConnect(): MapImage[] | string[] {\r\n\t\treturn this.getPropertyValue(\"imagesToConnect\");\r\n\t}\r\n\r\n\tprotected handleImagesToConnect() {\r\n\t\tif (this.imagesToConnect) {\r\n\t\t\tlet segment: Array<IGeoPoint> = [];\r\n\t\t\tlet multiGeoLine = [segment];\r\n\r\n\t\t\tfor (let image of this.imagesToConnect) {\r\n\t\t\t\tif ($type.isString(image)) {\r\n\t\t\t\t\tlet chart = this.series.chart;\r\n\t\t\t\t\tif (chart) {\r\n\t\t\t\t\t\tchart.series.each((series) => {\r\n\t\t\t\t\t\t\tif (series instanceof MapImageSeries) {\r\n\t\t\t\t\t\t\t\tlet img = series.getImageById(<string>image)\r\n\t\t\t\t\t\t\t\tif (img) {\r\n\t\t\t\t\t\t\t\t\timage = img;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (image instanceof MapImage) {\r\n\r\n\t\t\t\t\tsegment.push({ longitude: (<MapImage>image).longitude, latitude: (<MapImage>image).latitude });\r\n\r\n\t\t\t\t\tif (!this._imageListeners[image.uid]) {\r\n\t\t\t\t\t\tlet disposer = image.events.on(\"propertychanged\", (event) => {\r\n\t\t\t\t\t\t\tif (event.property == \"longitude\" || event.property == \"latitude\") {\r\n\t\t\t\t\t\t\t\tthis.handleImagesToConnect();\r\n\t\t\t\t\t\t\t\tthis.invalidate();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, this, false);\r\n\t\t\t\t\t\tthis._imageListeners[image.uid] = disposer;\r\n\t\t\t\t\t\tthis._disposers.push(disposer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.multiGeoLine = multiGeoLine;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the line, effectively forcing it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\t\tlet chart: MapChart = this.series.chart;\r\n\r\n\t\tif (this.multiLine) {\r\n\r\n\t\t\tif (!this.shortestDistance) {\r\n\r\n\t\t\t\tlet convertedPoints: Array<Array<IPoint>> = [];\r\n\r\n\t\t\t\tfor (let i = 0, len = this.multiLine.length; i < len; i++) {\r\n\r\n\t\t\t\t\tlet segment: Array<[number, number]> = this.multiLine[i];\r\n\r\n\t\t\t\t\tlet convertedSegmentPoints: Array<IPoint> = [];\r\n\r\n\t\t\t\t\tfor (let s = 0, slen = segment.length; s < slen; s++) {\r\n\t\t\t\t\t\tlet geoPoint: [number, number] = segment[s];\r\n\t\t\t\t\t\tlet point: IPoint = this.series.chart.projection.convert({ longitude: geoPoint[0], latitude: geoPoint[1] });\r\n\t\t\t\t\t\tconvertedSegmentPoints.push(point);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconvertedPoints.push(convertedSegmentPoints);\r\n\t\t\t\t}\r\n\t\t\t\tthis.line.segments = convertedPoints;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tchart.projection.d3Projection.precision(this.precision);\r\n\t\t\t\tthis.line.path = chart.projection.d3Path(<any>this.getFeature());\r\n\t\t\t}\r\n\r\n\t\t\tif (this._arrow) {\r\n\t\t\t\tthis._arrow.validatePosition();\r\n\t\t\t}\r\n\r\n\t\t\t$iter.each(this.lineObjects.iterator(), (x) => {\r\n\t\t\t\tx.validatePosition();\r\n\t\t\t});\r\n\r\n\t\t\tthis.handleGlobalScale();\r\n\t\t}\r\n\t\telse if (this.imagesToConnect) {\r\n\t\t\tthis.handleImagesToConnect();\r\n\t\t}\r\n\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic getFeature(): { \"type\": \"Feature\", geometry: { type: \"MultiLineString\", coordinates: Array<Array<[number, number]>> } } {\r\n\t\tif (this.multiLine && this.multiLine.length > 0 && this.multiLine[0] && this.multiLine[0].length > 0) {\r\n\t\t\treturn { \"type\": \"Feature\", geometry: { type: \"MultiLineString\", coordinates: this.multiLine } };\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic measureElement(): void {\r\n\t\t// Overriding, just to avoid extra measure\r\n\t}\r\n\r\n\t/**\r\n\t * The line should take the shortest path over the globe.\r\n\t *\r\n\t * Enabling this will make the line look differently in different\r\n\t * projections. Only `MapLine` supports this setting, `MapArc` and\r\n\t * `MapSplice` don't.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Real path?\r\n\t */\r\n\tpublic set shortestDistance(value: boolean) {\r\n\t\tthis.setPropertyValue(\"shortestDistance\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Real path?\r\n\t */\r\n\tpublic get shortestDistance(): boolean {\r\n\t\treturn this.getPropertyValue(\"shortestDistance\");\r\n\t}\r\n\r\n\t/**\r\n\t * List of separate line objects the line consists of.\r\n\t *\r\n\t * @readonly\r\n\t * @return List of line objects\r\n\t */\r\n\tpublic get lineObjects(): ListTemplate<MapLineObject> {\r\n\t\tif (!this._lineObjects) {\r\n\t\t\tthis._lineObjects = new ListTemplate<MapLineObject>(new MapLineObject());\r\n\t\t\tthis._lineObjects.events.on(\"inserted\", this.handleLineObjectAdded, this, false);\r\n\t\t\tthis._disposers.push(new ListDisposer(this._lineObjects));\r\n\t\t\tthis._disposers.push(this._lineObjects.template);\r\n\t\t}\r\n\r\n\t\treturn this._lineObjects;\r\n\t}\r\n\r\n\t/**\r\n\t * Decorate a [[LineObject]] when it is added to the line.\r\n\t *\r\n\t * @param event  Event\r\n\t */\r\n\tprotected handleLineObjectAdded(event: IListEvents<MapLineObject>[\"inserted\"]) {\r\n\t\tlet mapLineObject: MapLineObject = event.newValue;\r\n\t\tmapLineObject.mapLine = this;\r\n\t\tmapLineObject.shouldClone = false;\r\n\t\tmapLineObject.parent = this;\r\n\t}\r\n\r\n\t/**\r\n\t * A [[MapLineObject]] to use as an option arrowhead on the line.\r\n\t *\r\n\t * Just accessing this property will create a default arrowhead on the line\r\n\t * automatically.\r\n\t *\r\n\t * @param arrow  Arrow element\r\n\t */\r\n\tpublic set arrow(arrow: MapLineObject) {\r\n\t\tthis._arrow = arrow;\r\n\t\tarrow.mapLine = this;\r\n\t\tarrow.parent = this;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Arrow element\r\n\t */\r\n\tpublic get arrow(): MapLineObject {\r\n\t\tif (!this._arrow) {\r\n\t\t\tlet arrow: MapLineObject = this.createChild(MapLineObject);\r\n\t\t\tarrow.shouldClone = false;\r\n\t\t\tarrow.width = 8;\r\n\t\t\tarrow.height = 10;\r\n\t\t\tarrow.mapLine = this;\r\n\t\t\tarrow.position = 0.5;\r\n\r\n\t\t\tlet triangle = arrow.createChild(Triangle);\r\n\t\t\t//triangle.shouldClone = false;\r\n\t\t\ttriangle.fillOpacity = 1;\r\n\t\t\ttriangle.width = percent(100);\r\n\t\t\ttriangle.height = percent(100);\r\n\t\t\ttriangle.rotation = 90;\r\n\t\t\ttriangle.horizontalCenter = \"middle\";\r\n\t\t\ttriangle.verticalCenter = \"middle\";\r\n\t\t\tthis._arrow = arrow;\r\n\t\t}\r\n\t\treturn this._arrow;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies line properties and other attributes, like arrow, from another\r\n\t * instance of [[MapLine]].\r\n\t *\r\n\t * @param source  Source map line\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.line.copyFrom(source.line);\r\n\t\tthis.lineObjects.copyFrom(source.lineObjects);\r\n\t\tif (source._arrow) {\r\n\t\t\tthis.arrow = <MapLineObject>source.arrow.clone();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude of the line center.\r\n\t *\r\n\t * @readonly\r\n\t * @return Latitude\r\n\t */\r\n\tpublic get latitude(): number {\r\n\t\treturn this.north + (this.south - this.north) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Longitude of the line center.\r\n\t *\r\n\t * @readonly\r\n\t * @return Latitude\r\n\t */\r\n\tpublic get longitude(): number {\r\n\t\treturn this.east + (this.west - this.east) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * X coordinate for the slice tooltip.\r\n\t *\r\n\t * @ignore\r\n\t * @return X\r\n\t */\r\n\tpublic getTooltipX(): number {\r\n\t\tlet x = this.getPropertyValue(\"tooltipX\");\r\n\t\tif (!(x instanceof Percent)) {\r\n\t\t\tx = percent(50);\r\n\t\t}\r\n\t\tif (x instanceof Percent) {\r\n\t\t\treturn this.positionToPoint(x.value).x;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Y coordinate for the slice tooltip.\r\n\t *\r\n\t * @ignore\r\n\t * @return Y\r\n\t */\r\n\tpublic getTooltipY(): number {\r\n\t\tlet y = this.getPropertyValue(\"tooltipY\");\r\n\t\tif (!(y instanceof Percent)) {\r\n\t\t\ty = percent(50);\r\n\t\t}\r\n\t\tif (y instanceof Percent) {\r\n\t\t\treturn this.positionToPoint(y.value).y;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * When line is plotted, if its `shortestDistance` is set to `true` it is\r\n\t * bent according to the used projection, to depict the shortest distance how\r\n\t * it would go on the actual land.\r\n\t *\r\n\t * `precision` introduces a setting which can control when such bending\r\n\t * occurs.\r\n\t *\r\n\t * If the distance (in degrees) between line start and end points\r\n\t * is less than `precision`, no bending will take place and the line will be\r\n\t * straight.\r\n\t *\r\n\t * Set to large number (e.g. 10000) for perfectly straight line.\r\n\t *\r\n\t * @since 4.9.1\r\n\t * @default 0.1\r\n\t * @param  value  Precision\r\n\t */\r\n\tpublic set precision(value: number) {\r\n\t\tthis.setPropertyValue(\"precision\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Precision\r\n\t */\r\n\tpublic get precision(): number {\r\n\t\treturn this.getPropertyValue(\"precision\");\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"MapLine\"] = MapLine;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}