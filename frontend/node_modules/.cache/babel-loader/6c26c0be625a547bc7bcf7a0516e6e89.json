{"ast":null,"code":"/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { registry, is } from \"./Registry\";\nimport { Container } from \"./Container\";\nimport { raf } from \"./utils/AsyncPending\";\nimport { triggerIdle } from \"./utils/AsyncPending\";\nimport * as $array from \"./utils/Array\";\nimport * as $object from \"./utils/Object\";\nimport * as $log from \"./utils/Log\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * The main class that handles system-wide tasks, like caching, heartbeats, etc.\r\n * @important\r\n */\n\nvar System =\n/** @class */\nfunction () {\n  /**\r\n   * Performs initialization of the System object.\r\n   *\r\n   * Called when the first [[Sprite]] object is created.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  function System() {\n    /**\r\n     * A flag indicating if the system is on pause.\r\n     */\n    this._isPaused = false;\n    /**\r\n     * Holds the list of currently playing animations.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.animations = [];\n    /**\r\n     * Unique ID of the object.\r\n     */\n\n    this.uid = registry.getUniqueId();\n    /**\r\n     * @todo Description\r\n     * @todo Needed?\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.dummyCounter = 0;\n    this._frameRequested = false;\n    this.updateStepDuration = 45;\n    this.time = Date.now();\n  }\n  /**\r\n   * Reports time elapsed since timer was reset.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Needed?\r\n   * @param msg    Message to report in console\r\n   * @param reset  Reset time counter\r\n   */\n\n\n  System.prototype.reportTime = function (msg, reset) {\n    if (this.dummyCounter < 6) {//console.log(Date.now() - this.time, msg, this.dummyCounter2);\n    }\n\n    if (reset) {\n      this.time = Date.now();\n    }\n  };\n  /**\r\n   * Performs \"heartbeat\" operations `frameRate` number of times per second.\r\n   *\r\n   * When the chart element is invalidated, it is not immediately redrawn.\r\n   *\r\n   * Instead it waits for the next `update()` cycle to be re-validated.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Maybe should be private?\r\n   */\n\n\n  System.prototype.update = function () {\n    var _this = this;\n\n    if (this._isPaused) {\n      return;\n    }\n\n    this._frameRequested = false;\n    var time = Date.now();\n    registry.dispatchImmediately(\"enterframe\"); //this.validateLayouts();\n    //this.validatePositions();\n\n    /*\r\n            for (let key in registry.invalidLayouts) {\r\n                this.validateLayouts(key);\r\n            }\r\n            for (let key in registry.invalidPositions) {\r\n                this.validatePositions(key);\r\n            }\r\n    */\n\n    var skippedComponents = []; // data objects first - do all calculations\n    // only data is parsed in chunks, thats why we do for loop instead of a while like with other invalid items.\n    // important to go backwards, as items are removed!\n    // TODO use iterator instead\n\n    for (var key in registry.invalidDatas) {\n      if ($object.hasKey(registry.invalidDatas, key)) {\n        var invalidData = registry.invalidDatas[key];\n\n        while (invalidData.length > 0) {\n          var component = invalidData[0];\n          var dataProvider = component.dataProvider;\n\n          if (!component.isDisposed()) {\n            if (dataProvider && dataProvider.dataInvalid) {\n              try {\n                dataProvider.validateData();\n\n                if (dataProvider.dataValidationProgress < 1) {\n                  break;\n                }\n              } catch (e) {\n                $array.remove(invalidData, dataProvider);\n                dataProvider.raiseCriticalError(e);\n              }\n            } else {\n              try {\n                component.validateData();\n\n                if (component.dataValidationProgress < 1) {\n                  break;\n                }\n              } catch (e) {\n                $array.remove(invalidData, component);\n                component.raiseCriticalError(e);\n              }\n            }\n          } else {\n            $array.remove(invalidData, component);\n          }\n        }\n\n        if (Date.now() - time > this.updateStepDuration) {\n          break;\n        }\n      }\n    }\n\n    while (registry.invalidRawDatas.length > 0) {\n      var component = registry.invalidRawDatas[0];\n\n      if (!component.isDisposed()) {\n        try {\n          component.validateRawData();\n        } catch (e) {\n          $array.remove(registry.invalidRawDatas, component);\n          component.raiseCriticalError(e);\n        }\n      } else {\n        $array.remove(registry.invalidRawDatas, component);\n      }\n    } // TODO use iterator instead\n\n\n    while (registry.invalidDataItems.length > 0) {\n      var component = registry.invalidDataItems[0];\n      var dataProvider = component.dataProvider; // this is needed to avoid partial value validation when data is parsed in chunks\n\n      if (component.isDisposed() || component.dataInvalid || dataProvider && dataProvider.dataInvalid) {// void\n      } else {\n        try {\n          component.validateDataItems();\n        } catch (e) {\n          $array.remove(registry.invalidDataItems, component);\n          component.raiseCriticalError(e);\n        }\n      } // this might seem too much, as validateValues removes from invalidDataItems aswell, but just to be sure (in case validateData is overriden and no super is called)\n\n\n      $array.remove(registry.invalidDataItems, component);\n    } // TODO use iterator instead\n\n\n    while (registry.invalidDataRange.length > 0) {\n      var component = registry.invalidDataRange[0];\n      var dataProvider = component.dataProvider;\n\n      if (component.isDisposed() || component.dataInvalid || dataProvider && dataProvider.dataInvalid) {// void\n      } else {\n        try {\n          component.validateDataRange();\n\n          if (!component.skipRangeEvent) {\n            component.dispatchImmediately(\"datarangechanged\");\n          }\n\n          component.skipRangeEvent = false;\n        } catch (e) {\n          $array.remove(registry.invalidDataRange, component);\n          component.raiseCriticalError(e);\n        }\n      } // this might seem too much, as validateDataRange removes from invalidDataRange aswell, but just to be sure (in case validateData is overriden and no super is called)\n\n\n      $array.remove(registry.invalidDataRange, component);\n    }\n\n    var skippedSprites = []; // display objects later\n    // TODO use iterator instead\n\n    $object.each(registry.invalidLayouts, function (key) {\n      _this.validateLayouts(key);\n    });\n    $object.each(registry.invalidPositions, function (key) {\n      _this.validatePositions(key);\n    });\n    var hasSkipped = false;\n    time = Date.now();\n    $object.each(registry.invalidSprites, function (key, invalidSprites) {\n      var count = 0;\n\n      while (invalidSprites.length > 0) {\n        _this.validateLayouts(key);\n\n        _this.validatePositions(key);\n\n        count++;\n\n        if (count == 5) {\n          if (Date.now() - time > _this.updateStepDuration) {\n            break;\n          }\n\n          count = 0;\n        }\n\n        var sprite = invalidSprites[invalidSprites.length - 1]; // we need to check this, as validateLayout might validate sprite\n\n        if (sprite && !sprite.isDisposed()) {\n          if (!sprite._systemCheckIfValidate()) {\n            // void\n            skippedSprites.push(sprite);\n          } else {\n            if (!_this.checkIfValidate2(sprite)) {\n              // void\n              skippedSprites.push(sprite);\n            } else {\n              try {\n                sprite._systemUpdate(skippedSprites);\n              } catch (e) {\n                sprite.invalid = false;\n                $array.remove(invalidSprites, sprite);\n                sprite.raiseCriticalError(e);\n              }\n            }\n          } // this might seem too much, but it's ok\n\n\n          sprite.invalid = false;\n        }\n\n        $array.remove(invalidSprites, sprite);\n      }\n\n      registry.invalidSprites[key] = registry.invalidSprites[key].concat(skippedSprites);\n    });\n    $object.each(registry.invalidSprites, function (key, value) {\n      if (value.length > 0) {\n        hasSkipped = true;\n      }\n    });\n    $object.each(registry.invalidDatas, function (key, value) {\n      if (value.length > 0) {\n        hasSkipped = true;\n      }\n    }); // TODO make this more efficient\n    // TODO don't copy the array\n\n    $array.each($array.copy(this.animations), function (x) {\n      x.update();\n    }); //if(!hasSkipped){\n\n    $object.each(registry.invalidLayouts, function (key) {\n      _this.validateLayouts(key);\n    });\n    $object.each(registry.invalidPositions, function (key) {\n      _this.validatePositions(key);\n    }); //}\n\n    triggerIdle();\n    $object.each(registry.invalidLayouts, function (key) {\n      _this.validateLayouts(key);\n    });\n    $object.each(registry.invalidPositions, function (key) {\n      _this.validatePositions(key);\n    });\n    registry.dispatchImmediately(\"exitframe\");\n\n    if (hasSkipped || this.animations.length > 0 || skippedComponents.length > 0) {\n      this.requestFrame();\n    }\n\n    if (this.updateStepDuration < 200) {\n      var all0_1 = true;\n      $object.each(registry.invalidDatas, function (key, value) {\n        if (value.length > 0) {\n          all0_1 = false;\n        }\n      });\n      $object.each(registry.invalidSprites, function (key, value) {\n        if (value.length > 0) {\n          all0_1 = false;\n        }\n      });\n\n      if (all0_1) {\n        this.updateStepDuration = 200;\n      }\n    }\n  };\n\n  System.prototype.checkIfValidate2 = function (sprite) {\n    if (sprite.dataItem && sprite.dataItem.component && sprite.dataItem.component.dataInvalid && !sprite.dataItem.component.isTemplate) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  /**\r\n   * Requests new animation frame\r\n   */\n\n\n  System.prototype.requestFrame = function () {\n    var _this = this;\n\n    if (!this._frameRequested) {\n      raf(function () {\n        _this.update();\n      });\n      this._frameRequested = true;\n    }\n  };\n  /**\r\n   * Call this method if you update data or config of a chart that is in\r\n   * hidden container, after revealing the container, so that labels and\r\n   * possibly other elements can correctly arrange themselves.\r\n   *\r\n   * @since 4.7.10\r\n   * @param  container  Target container\r\n   */\n\n\n  System.prototype.softInvalidate = function (container) {\n    var _this = this;\n\n    container.children.each(function (child) {\n      if (child instanceof Container) {\n        _this.softInvalidate(child);\n      }\n\n      if (child.measureFailed) {\n        if (is(child, \"Label\")) {\n          child.hardInvalidate();\n        } else {\n          child.invalidate();\n        }\n\n        child.measureFailed = false;\n      }\n    });\n  };\n  /**\r\n   * Triggers position re-validation on all [[Sprite]] elements that have\r\n   * invalid(ated) positions.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Maybe should be private?\r\n   */\n\n\n  System.prototype.validatePositions = function (id) {\n    // invalid positions\n    // TODO use iterator instead\n    var invalidPositions = registry.invalidPositions[id];\n\n    while (invalidPositions.length > 0) {\n      var sprite = invalidPositions[invalidPositions.length - 1];\n\n      if (!sprite.isDisposed()) {\n        try {\n          sprite._systemValidatePositions();\n        } catch (e) {\n          sprite.positionInvalid = false;\n          $array.remove(invalidPositions, sprite);\n          sprite.raiseCriticalError(e);\n        }\n      } else {\n        $array.remove(invalidPositions, sprite);\n      }\n    }\n  };\n  /**\r\n   * Triggers position re-validation on all [[Container]] elements that have\r\n   * invalid(ated) layouts.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Maybe should be private?\r\n   */\n\n\n  System.prototype.validateLayouts = function (id) {\n    // invalid positions\n    // TODO use iterator instead\n    var invalidLayouts = registry.invalidLayouts[id];\n\n    while (invalidLayouts.length > 0) {\n      var container = invalidLayouts[invalidLayouts.length - 1];\n\n      if (!container.isDisposed()) {\n        try {\n          container.children.each(function (sprite) {\n            sprite._systemValidateLayouts();\n          });\n          container.validateLayout();\n        } catch (e) {\n          container.layoutInvalid = false;\n          $array.remove(invalidLayouts, container);\n          container.raiseCriticalError(e);\n        }\n      } else {\n        $array.remove(invalidLayouts, container);\n      }\n    }\n  };\n  /**\r\n   * Outputs string to console if `verbose` is `true`.\r\n   *\r\n   * @param value Message to output to console\r\n   */\n\n\n  System.prototype.log = function (value) {\n    $log.log(value);\n  };\n\n  Object.defineProperty(System.prototype, \"isPaused\", {\n    /**\r\n     * @return Is system on pause?\r\n     */\n    get: function get() {\n      return this._isPaused;\n    },\n\n    /**\r\n     * Pauses all the processes of all the amCharts objects on the page\r\n     *\r\n     * @return is paused?\r\n     */\n    set: function set(value) {\n      this._isPaused = value;\n\n      if (!value) {\n        this._frameRequested = false;\n        this.requestFrame();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * amCharts Version.\r\n   *\r\n   * This follows npm's semver specification.\r\n   *\r\n   * @see {@link https://docs.npmjs.com/misc/semver}\r\n   */\n\n  System.VERSION = \"4.9.17\";\n  return System;\n}();\n\nexport { System };\n/**\r\n * A singleton global instance of [[System]].\r\n *\r\n * All code should use this, rather than instantiating their\r\n * own System objects.\r\n */\n\nexport var system = new System();","map":{"version":3,"sources":["../../../../src/.internal/core/System.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { registry, is } from \"./Registry\";\r\nimport { Sprite } from \"./Sprite\";\r\nimport { Container } from \"./Container\";\r\nimport { Component } from \"./Component\";\r\nimport { Label } from \"./elements/Label\";\r\nimport { raf } from \"./utils/AsyncPending\";\r\nimport { IAnimationObject } from \"./utils/Animation\";\r\nimport { triggerIdle } from \"./utils/AsyncPending\";\r\nimport * as $array from \"./utils/Array\";\r\nimport * as $object from \"./utils/Object\";\r\nimport * as $type from \"./utils/Type\";\r\nimport * as $log from \"./utils/Log\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * The main class that handles system-wide tasks, like caching, heartbeats, etc.\r\n * @important\r\n */\r\nexport class System {\r\n\t/**\r\n\t * A flag indicating if the system is on pause.\r\n\t */\r\n\tprotected _isPaused: boolean = false;\r\n\r\n\t/**\r\n\t * Holds the list of currently playing animations.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic animations: Array<IAnimationObject> = [];\r\n\r\n\t/**\r\n\t * Unique ID of the object.\r\n\t */\r\n\tpublic uid: string = registry.getUniqueId();\r\n\r\n\t/**\r\n\t * amCharts Version.\r\n\t *\r\n\t * This follows npm's semver specification.\r\n\t *\r\n\t * @see {@link https://docs.npmjs.com/misc/semver}\r\n\t */\r\n\tstatic VERSION: string = \"4.9.17\";\r\n\r\n\t/**\r\n\t * @todo Description\r\n\t * @todo Needed?\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic dummyCounter: number = 0;\r\n\r\n\t/**\r\n\t * @todo Description\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic time: number;\r\n\r\n\r\n\tprotected _frameRequested: boolean = false;\r\n\r\n\tpublic updateStepDuration: number = 45;\r\n\r\n\t/**\r\n\t * Performs initialization of the System object.\r\n\t *\r\n\t * Called when the first [[Sprite]] object is created.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic constructor() {\r\n\t\tthis.time = Date.now();\r\n\t}\r\n\r\n\t/**\r\n\t * Reports time elapsed since timer was reset.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Needed?\r\n\t * @param msg    Message to report in console\r\n\t * @param reset  Reset time counter\r\n\t */\r\n\tpublic reportTime(msg: string, reset?: boolean): void {\r\n\t\tif (this.dummyCounter < 6) {\r\n\t\t\t//console.log(Date.now() - this.time, msg, this.dummyCounter2);\r\n\t\t}\r\n\t\tif (reset) {\r\n\t\t\tthis.time = Date.now();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Performs \"heartbeat\" operations `frameRate` number of times per second.\r\n\t *\r\n\t * When the chart element is invalidated, it is not immediately redrawn.\r\n\t *\r\n\t * Instead it waits for the next `update()` cycle to be re-validated.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Maybe should be private?\r\n\t */\r\n\tpublic update(): void {\r\n\r\n\t\tif (this._isPaused) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._frameRequested = false;\r\n\r\n\t\tlet time = Date.now();\r\n\r\n\t\tregistry.dispatchImmediately(\"enterframe\");\r\n\r\n\t\t//this.validateLayouts();\r\n\t\t//this.validatePositions();\r\n\t\t/*\r\n\t\t\t\tfor (let key in registry.invalidLayouts) {\r\n\t\t\t\t\tthis.validateLayouts(key);\r\n\t\t\t\t}\r\n\t\t\t\tfor (let key in registry.invalidPositions) {\r\n\t\t\t\t\tthis.validatePositions(key);\r\n\t\t\t\t}\r\n\t\t*/\r\n\r\n\t\tlet skippedComponents: Component[] = [];\r\n\r\n\t\t// data objects first - do all calculations\r\n\t\t// only data is parsed in chunks, thats why we do for loop instead of a while like with other invalid items.\r\n\t\t// important to go backwards, as items are removed!\r\n\t\t// TODO use iterator instead\r\n\r\n\t\tfor (let key in registry.invalidDatas) {\r\n\t\t\tif ($object.hasKey(registry.invalidDatas, key)) {\r\n\t\t\t\tlet invalidData = registry.invalidDatas[key];\r\n\r\n\t\t\t\twhile (invalidData.length > 0) {\r\n\t\t\t\t\tlet component: Component = invalidData[0];\r\n\t\t\t\t\tlet dataProvider: $type.Optional<Component> = component.dataProvider;\r\n\r\n\t\t\t\t\tif (!component.isDisposed()) {\r\n\r\n\t\t\t\t\t\tif (dataProvider && dataProvider.dataInvalid) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tdataProvider.validateData();\r\n\t\t\t\t\t\t\t\tif (dataProvider.dataValidationProgress < 1) {\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch (e) {\r\n\t\t\t\t\t\t\t\t$array.remove(invalidData, dataProvider);\r\n\t\t\t\t\t\t\t\tdataProvider.raiseCriticalError(e);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tcomponent.validateData();\r\n\t\t\t\t\t\t\t\tif (component.dataValidationProgress < 1) {\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch (e) {\r\n\t\t\t\t\t\t\t\t$array.remove(invalidData, component);\r\n\t\t\t\t\t\t\t\tcomponent.raiseCriticalError(e);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t$array.remove(invalidData, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (Date.now() - time > this.updateStepDuration) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (registry.invalidRawDatas.length > 0) {\r\n\t\t\tlet component: Component = registry.invalidRawDatas[0];\r\n\t\t\tif (!component.isDisposed()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcomponent.validateRawData();\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\t$array.remove(registry.invalidRawDatas, component);\r\n\t\t\t\t\tcomponent.raiseCriticalError(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$array.remove(registry.invalidRawDatas, component);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// TODO use iterator instead\r\n\t\twhile (registry.invalidDataItems.length > 0) {\r\n\t\t\tlet component: Component = registry.invalidDataItems[0];\r\n\r\n\t\t\tlet dataProvider: $type.Optional<Component> = component.dataProvider;\r\n\r\n\t\t\t// this is needed to avoid partial value validation when data is parsed in chunks\r\n\t\t\tif (component.isDisposed() || component.dataInvalid || (dataProvider && dataProvider.dataInvalid)) {\r\n\t\t\t\t// void\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcomponent.validateDataItems();\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\t$array.remove(registry.invalidDataItems, component);\r\n\t\t\t\t\tcomponent.raiseCriticalError(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// this might seem too much, as validateValues removes from invalidDataItems aswell, but just to be sure (in case validateData is overriden and no super is called)\r\n\t\t\t$array.remove(registry.invalidDataItems, component);\r\n\t\t}\r\n\r\n\t\t// TODO use iterator instead\r\n\t\twhile (registry.invalidDataRange.length > 0) {\r\n\t\t\tlet component: Component = registry.invalidDataRange[0];\r\n\r\n\t\t\tlet dataProvider: $type.Optional<Component> = component.dataProvider;\r\n\r\n\t\t\tif (component.isDisposed() || component.dataInvalid || (dataProvider && dataProvider.dataInvalid)) {\r\n\t\t\t\t// void\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcomponent.validateDataRange();\r\n\t\t\t\t\tif (!component.skipRangeEvent) {\r\n\t\t\t\t\t\tcomponent.dispatchImmediately(\"datarangechanged\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcomponent.skipRangeEvent = false;\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\t$array.remove(registry.invalidDataRange, component);\r\n\t\t\t\t\tcomponent.raiseCriticalError(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// this might seem too much, as validateDataRange removes from invalidDataRange aswell, but just to be sure (in case validateData is overriden and no super is called)\r\n\t\t\t$array.remove(registry.invalidDataRange, component);\r\n\t\t}\r\n\r\n\t\tlet skippedSprites: Sprite[] = [];\r\n\r\n\t\t// display objects later\r\n\t\t// TODO use iterator instead\r\n\r\n\t\t$object.each(registry.invalidLayouts, (key) => {\r\n\t\t\tthis.validateLayouts(key);\r\n\t\t});\r\n\r\n\t\t$object.each(registry.invalidPositions, (key) => {\r\n\t\t\tthis.validatePositions(key);\r\n\t\t});\r\n\r\n\r\n\t\tlet hasSkipped: boolean = false;\r\n\r\n\t\ttime = Date.now();\r\n\r\n\t\t$object.each(registry.invalidSprites, (key, invalidSprites) => {\r\n\t\t\tlet count = 0;\r\n\r\n\t\t\twhile (invalidSprites.length > 0) {\r\n\t\t\t\tthis.validateLayouts(key);\r\n\t\t\t\tthis.validatePositions(key);\r\n\r\n\t\t\t\tcount++;\r\n\r\n\t\t\t\tif (count == 5) {\r\n\t\t\t\t\tif (Date.now() - time > this.updateStepDuration) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcount = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet sprite: Sprite = invalidSprites[invalidSprites.length - 1];\r\n\r\n\t\t\t\t// we need to check this, as validateLayout might validate sprite\r\n\t\t\t\tif (sprite && !sprite.isDisposed()) {\r\n\t\t\t\t\tif (!sprite._systemCheckIfValidate()) {\r\n\t\t\t\t\t\t// void\r\n\t\t\t\t\t\tskippedSprites.push(sprite);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif (!this.checkIfValidate2(sprite)) {\r\n\t\t\t\t\t\t\t// void\r\n\t\t\t\t\t\t\tskippedSprites.push(sprite);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tsprite._systemUpdate(skippedSprites);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch (e) {\r\n\t\t\t\t\t\t\t\tsprite.invalid = false;\r\n\t\t\t\t\t\t\t\t$array.remove(invalidSprites, sprite);\r\n\t\t\t\t\t\t\t\tsprite.raiseCriticalError(e);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// this might seem too much, but it's ok\r\n\t\t\t\t\tsprite.invalid = false;\r\n\t\t\t\t}\r\n\t\t\t\t$array.remove(invalidSprites, sprite);\r\n\t\t\t}\r\n\r\n\t\t\tregistry.invalidSprites[key] = registry.invalidSprites[key].concat(skippedSprites);\r\n\t\t});\r\n\r\n\t\t$object.each(registry.invalidSprites, (key, value) => {\r\n\t\t\tif (value.length > 0) {\r\n\t\t\t\thasSkipped = true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t$object.each(registry.invalidDatas, (key, value) => {\r\n\t\t\tif (value.length > 0) {\r\n\t\t\t\thasSkipped = true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// TODO make this more efficient\r\n\t\t// TODO don't copy the array\r\n\t\t$array.each($array.copy(this.animations), (x) => {\r\n\t\t\tx.update();\r\n\t\t});\r\n\r\n\t\t//if(!hasSkipped){\r\n\t\t$object.each(registry.invalidLayouts, (key) => {\r\n\t\t\tthis.validateLayouts(key);\r\n\t\t});\r\n\r\n\t\t$object.each(registry.invalidPositions, (key) => {\r\n\t\t\tthis.validatePositions(key);\r\n\t\t});\r\n\t\t//}\r\n\r\n\t\ttriggerIdle();\r\n\r\n\t\t$object.each(registry.invalidLayouts, (key) => {\r\n\t\t\tthis.validateLayouts(key);\r\n\t\t});\r\n\r\n\t\t$object.each(registry.invalidPositions, (key) => {\r\n\t\t\tthis.validatePositions(key);\r\n\t\t});\r\n\r\n\r\n\t\tregistry.dispatchImmediately(\"exitframe\");\r\n\r\n\t\tif (hasSkipped || this.animations.length > 0 || skippedComponents.length > 0) {\r\n\t\t\tthis.requestFrame();\r\n\t\t}\r\n\r\n\t\tif (this.updateStepDuration < 200) {\r\n\t\t\tlet all0 = true;\r\n\r\n\t\t\t$object.each(registry.invalidDatas, (key, value) => {\r\n\t\t\t\tif (value.length > 0) {\r\n\t\t\t\t\tall0 = false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t$object.each(registry.invalidSprites, (key, value) => {\r\n\t\t\t\tif (value.length > 0) {\r\n\t\t\t\t\tall0 = false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (all0) {\r\n\t\t\t\tthis.updateStepDuration = 200;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic checkIfValidate2(sprite: Sprite): boolean {\r\n\t\tif (sprite.dataItem && sprite.dataItem.component && sprite.dataItem.component.dataInvalid && !sprite.dataItem.component.isTemplate) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Requests new animation frame\r\n\t */\r\n\tpublic requestFrame() {\r\n\t\tif (!this._frameRequested) {\r\n\r\n\t\t\traf(() => {\r\n\t\t\t\tthis.update();\r\n\t\t\t});\r\n\t\t\tthis._frameRequested = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Call this method if you update data or config of a chart that is in\r\n\t * hidden container, after revealing the container, so that labels and\r\n\t * possibly other elements can correctly arrange themselves.\r\n\t *\r\n\t * @since 4.7.10\r\n\t * @param  container  Target container\r\n\t */\r\n\tpublic softInvalidate(container: Container) {\r\n\t\tcontainer.children.each((child) => {\r\n\t\t\tif (child instanceof Container) {\r\n\t\t\t\tthis.softInvalidate(child);\r\n\t\t\t}\r\n\t\t\tif (child.measureFailed) {\r\n\t\t\t\tif (is<Label>(child, \"Label\")) {\r\n\t\t\t\t\tchild.hardInvalidate();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tchild.invalidate();\r\n\t\t\t\t}\r\n\t\t\t\tchild.measureFailed = false;\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Triggers position re-validation on all [[Sprite]] elements that have\r\n\t * invalid(ated) positions.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Maybe should be private?\r\n\t */\r\n\tpublic validatePositions(id: string): void {\r\n\t\t// invalid positions\r\n\t\t// TODO use iterator instead\r\n\t\tlet invalidPositions = registry.invalidPositions[id];\r\n\r\n\t\twhile (invalidPositions.length > 0) {\r\n\t\t\tlet sprite: Sprite = invalidPositions[invalidPositions.length - 1];\r\n\t\t\tif (!sprite.isDisposed()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tsprite._systemValidatePositions();\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tsprite.positionInvalid = false;\r\n\t\t\t\t\t$array.remove(invalidPositions, sprite);\r\n\t\t\t\t\tsprite.raiseCriticalError(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$array.remove(invalidPositions, sprite);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Triggers position re-validation on all [[Container]] elements that have\r\n\t * invalid(ated) layouts.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Maybe should be private?\r\n\t */\r\n\tpublic validateLayouts(id: string): void {\r\n\t\t// invalid positions\r\n\t\t// TODO use iterator instead\r\n\t\tlet invalidLayouts = registry.invalidLayouts[id];\r\n\t\twhile (invalidLayouts.length > 0) {\r\n\t\t\tlet container: Container = invalidLayouts[invalidLayouts.length - 1];\r\n\t\t\tif (!container.isDisposed()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcontainer.children.each((sprite) => {\r\n\t\t\t\t\t\tsprite._systemValidateLayouts();\r\n\t\t\t\t\t})\r\n\r\n\t\t\t\t\tcontainer.validateLayout();\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tcontainer.layoutInvalid = false;\r\n\t\t\t\t\t$array.remove(invalidLayouts, container);\r\n\t\t\t\t\tcontainer.raiseCriticalError(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$array.remove(invalidLayouts, container);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Outputs string to console if `verbose` is `true`.\r\n\t *\r\n\t * @param value Message to output to console\r\n\t */\r\n\tpublic log(value: any): void {\r\n\t\t$log.log(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Pauses all the processes of all the amCharts objects on the page\r\n\t *\r\n\t * @return is paused?\r\n\t */\r\n\tpublic set isPaused(value: boolean) {\r\n\t\tthis._isPaused = value;\r\n\t\tif (!value) {\r\n\t\t\tthis._frameRequested = false;\r\n\t\t\tthis.requestFrame();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Is system on pause?\r\n\t */\r\n\tpublic get isPaused(): boolean {\r\n\t\treturn this._isPaused;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * A singleton global instance of [[System]].\r\n *\r\n * All code should use this, rather than instantiating their\r\n * own System objects.\r\n */\r\nexport const system: System = new System();\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}