{"ast":null,"code":"/**\r\n * This module contains funcitonality related to geographical projections\r\n */\nimport { registry } from \"../../../core/Registry\";\nimport * as $math from \"../../../core/utils/Math\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * This is a base class for a geographical projection.\r\n */\n\nvar Projection =\n/** @class */\nfunction () {\n  function Projection() {\n    this.d3Projection = d3geo.geoEquirectangular();\n  }\n\n  Object.defineProperty(Projection.prototype, \"d3Projection\", {\n    /**\r\n     * d3 projection\r\n     */\n    get: function get() {\n      return this._d3Projection;\n    },\n\n    /**\r\n     * d3 projection\r\n     */\n    set: function set(projection) {\n      this._d3Projection = projection;\n      projection.precision(0.1);\n      this._d3Path = d3geo.geoPath().projection(projection);\n\n      if (this.chart) {\n        this.chart.invalidateProjection();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Projection.prototype, \"d3Path\", {\n    /**\r\n     * d3 path generator method\r\n     * @ignore\r\n     */\n    get: function get() {\n      return this._d3Path;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Projection.prototype, \"scale\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function get() {\n      return this.d3Projection.scale() / 100;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a geographical point (lat/long) to a screen point (x/y)\r\n   * @param geoPoint Geo point (lat/long)\r\n   * @return Screen point (x/y)\r\n   */\n\n  Projection.prototype.convert = function (geoPoint) {\n    /*\r\n    geoPoint = $geo.normalizePoint(geoPoint);\r\n    geoPoint = this.rotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n    let pointInRadians: IPoint = this.project(geoPoint.longitude * $math.RADIANS, geoPoint.latitude * $math.RADIANS);\r\n    return {\r\n        x: $math.round(pointInRadians.x * $math.DEGREES - this.centerPoint.x, 4) * this.scale,\r\n        y: $math.round(-pointInRadians.y * $math.DEGREES - this.centerPoint.y, 4) * this.scale\r\n    };*/\n    var p = this.d3Projection([geoPoint.longitude, geoPoint.latitude]);\n\n    if (p) {\n      return {\n        x: p[0],\n        y: p[1]\n      };\n    }\n  };\n  /**\r\n   * Converts a screen point (x/y) to a geographical point (lat/long)\r\n   * @param point Screen point (x/y)\r\n   * @return Geo point (lat/long)\r\n   */\n\n\n  Projection.prototype.invert = function (point) {\n    /*\r\n    let pointInRadians: IGeoPoint = this.unproject((point.x / this.scale + this.centerPoint.x) * $math.RADIANS, (-point.y / this.scale - this.centerPoint.y) * $math.RADIANS);\r\n      let geoPoint = { longitude: pointInRadians.longitude * $math.DEGREES, latitude: pointInRadians.latitude * $math.DEGREES };\r\n      geoPoint = this.unrotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n    */\n    var p = this.d3Projection.invert([point.x, point.y]);\n\n    if (p) {\n      return {\n        longitude: p[0],\n        latitude: p[1]\n      };\n    }\n  };\n  /**\r\n   * Returns X/Y coordinates.\r\n   * Individual projections will override this method to apply their own\r\n   * projection logic.\r\n   * @deprecated\r\n   * @param lambda [description]\r\n   * @param phi    [description]\r\n   * @return X/Y coordinates\r\n   * @todo Needs description\r\n   */\n\n\n  Projection.prototype.project = function (lambda, phi) {\n    return this.convert({\n      longitude: lambda * $math.DEGREES,\n      latitude: phi * $math.DEGREES\n    });\n  };\n  /**\r\n   * Returns geographical coordinates (lat/long).\r\n   * Individual projections will override this method to apply their own\r\n   * projection logic.\r\n   * @deprecated\r\n   * @param x X coordinate\r\n   * @param y Y coordinate\r\n   * @return Geographical point\r\n   * @todo Needs description\r\n   */\n\n\n  Projection.prototype.unproject = function (x, y) {\n    return this.invert({\n      x: x,\n      y: y\n    });\n  };\n  /**\r\n   * @ignore\r\n   * @deprecated\r\n   */\n\n\n  Projection.prototype.rotate = function (geoPoint, deltaLongitude, deltaLatitude, deltaGamma) {\n    var deltaLambda = deltaLongitude * $math.RADIANS;\n    var deltaPhi = deltaLatitude * $math.RADIANS;\n    deltaGamma = deltaGamma * $math.RADIANS;\n    var lambda = geoPoint.longitude * $math.RADIANS + deltaLambda;\n    var phi = geoPoint.latitude * $math.RADIANS;\n    var cosDeltaPhi = Math.cos(deltaPhi);\n    var sinDeltaPhi = Math.sin(deltaPhi);\n    var cosDeltaGamma = Math.cos(deltaGamma);\n    var sinDeltaGamma = Math.sin(deltaGamma);\n    var cosPhi = Math.cos(phi);\n    var x = Math.cos(lambda) * cosPhi;\n    var y = Math.sin(lambda) * cosPhi;\n    var z = Math.sin(phi);\n    var k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return {\n      longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      latitude: $math.DEGREES * Math.asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    };\n  };\n  /**\r\n   * @ignore\r\n   * @deprecated\r\n   */\n\n\n  Projection.prototype.unrotate = function (geoPoint, deltaLongitude, deltaLatitude, deltaGamma) {\n    var deltaLambda = deltaLongitude * $math.RADIANS;\n    var deltaPhi = deltaLatitude * $math.RADIANS;\n    deltaGamma = deltaGamma * $math.RADIANS;\n    var lambda = geoPoint.longitude * $math.RADIANS - deltaLambda;\n    var phi = geoPoint.latitude * $math.RADIANS;\n    var cosDeltaPhi = Math.cos(deltaPhi);\n    var sinDeltaPhi = Math.sin(deltaPhi);\n    var cosDeltaGamma = Math.cos(deltaGamma);\n    var sinDeltaGamma = Math.sin(deltaGamma);\n    var cosPhi = Math.cos(phi);\n    var x = Math.cos(lambda) * cosPhi;\n    var y = Math.sin(lambda) * cosPhi;\n    var z = Math.sin(phi);\n    var k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return {\n      longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      latitude: $math.DEGREES * Math.asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    };\n  }; //@todo: move to some utils?\n  //@todo: add credits to: https://www.movable-type.co.uk/scripts/latlong.html\n\n\n  Projection.prototype.intermediatePoint = function (pointA, pointB, position) {\n    var p = d3geo.geoInterpolate([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude])(position);\n    return {\n      longitude: p[0],\n      latitude: p[1]\n    };\n  };\n\n  ; // returns radians\n\n  Projection.prototype.multiDistance = function (multiGeoLine) {\n    var distance = 0;\n\n    for (var s = 0; s < multiGeoLine.length; s++) {\n      var points = multiGeoLine[s];\n\n      if (points.length > 1) {\n        for (var p = 1; p < points.length; p++) {\n          var pointA = points[p - 1];\n          var pointB = points[p];\n          distance += this.distance(pointA, pointB);\n        }\n      }\n    }\n\n    return distance;\n  }; // returns radians\n\n\n  Projection.prototype.distance = function (pointA, pointB) {\n    return d3geo.geoDistance([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude]);\n  };\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n\n\n  Projection.prototype.positionToPoint = function (multiGeoLine, position) {\n    if (multiGeoLine) {\n      var intermediatePoint = this.positionToGeoPoint(multiGeoLine, position);\n      var intermediatePointA = this.positionToGeoPoint(multiGeoLine, position - 0.01);\n      var intermediatePointB = this.positionToGeoPoint(multiGeoLine, position + 0.01);\n\n      if (intermediatePointA && intermediatePointB) {\n        var point = this.convert(intermediatePoint);\n        var pa = this.convert(intermediatePointA);\n        var pb = this.convert(intermediatePointB);\n        return {\n          x: point.x,\n          y: point.y,\n          angle: $math.getAngle(pa, pb)\n        };\n      }\n    }\n\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  };\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n\n\n  Projection.prototype.positionToGeoPoint = function (multiGeoLine, position) {\n    if (multiGeoLine) {\n      var totalDistance = this.multiDistance(multiGeoLine);\n      var currentDistance = 0;\n      var distanceAB = void 0;\n      var positionA = 0;\n      var positionB = 0;\n      var pointA = void 0;\n      var pointB = void 0;\n\n      for (var s = 0; s < multiGeoLine.length; s++) {\n        var points = multiGeoLine[s];\n\n        if (points.length > 1) {\n          for (var p = 1; p < points.length; p++) {\n            pointA = points[p - 1];\n            pointB = points[p];\n            positionA = currentDistance / totalDistance;\n            distanceAB = this.distance(pointA, pointB);\n            currentDistance += distanceAB;\n            positionB = currentDistance / totalDistance;\n\n            if (positionA <= position && positionB > position) {\n              s = multiGeoLine.length;\n              break;\n            }\n          }\n        } else if (points.length == 1) {\n          pointA = points[0];\n          pointB = points[0];\n          positionA = 0;\n          positionB = 1;\n        }\n      }\n\n      if (pointA && pointB) {\n        var positionAB = (position - positionA) / (positionB - positionA);\n        return this.intermediatePoint(pointA, pointB, positionAB);\n      }\n    }\n\n    return {\n      longitude: 0,\n      latitude: 0\n    };\n  };\n\n  return Projection;\n}();\n\nexport { Projection };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Projection\"] = Projection;","map":{"version":3,"sources":["../../../../../../src/.internal/charts/map/projections/Projection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * This module contains funcitonality related to geographical projections\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IGeoPoint } from \"../../../core/defs/IGeoPoint\";\r\n//import { IGeoRectangle } from \"../../../core/defs/IGeoRectangle\";\r\nimport { IPoint, IOrientationPoint } from \"../../../core/defs/IPoint\";\r\nimport { registry } from \"../../../core/Registry\";\r\nimport * as $math from \"../../../core/utils/Math\";\r\nimport * as d3geo from \"d3-geo\";\r\nimport { MapChart } from \"../../types/MapChart\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * This is a base class for a geographical projection.\r\n */\r\nexport class Projection {\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _d3Projection: d3geo.GeoProjection;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _d3Path: d3geo.GeoPath;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic chart: MapChart;\r\n\r\n\r\n\tconstructor() {\r\n\t\tthis.d3Projection = d3geo.geoEquirectangular();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * d3 projection\r\n\t */\r\n\tpublic set d3Projection(projection: d3geo.GeoProjection) {\r\n\t\tthis._d3Projection = projection;\r\n\t\tprojection.precision(0.1);\r\n\t\tthis._d3Path = d3geo.geoPath().projection(projection);\r\n\r\n\t\tif (this.chart) {\r\n\t\t\tthis.chart.invalidateProjection();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * d3 projection\r\n\t */\r\n\tpublic get d3Projection(): d3geo.GeoProjection {\r\n\t\treturn this._d3Projection;\r\n\t}\r\n\r\n\t/**\r\n\t * d3 path generator method\r\n\t * @ignore\r\n\t */\r\n\tpublic get d3Path(): d3geo.GeoPath {\r\n\t\treturn this._d3Path;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic get scale(): number {\r\n\t\treturn this.d3Projection.scale() / 100;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a geographical point (lat/long) to a screen point (x/y)\r\n\t * @param geoPoint Geo point (lat/long)\r\n\t * @return Screen point (x/y)\r\n\t */\r\n\tpublic convert(geoPoint: IGeoPoint): IPoint {\r\n\t\t/*\r\n\t\tgeoPoint = $geo.normalizePoint(geoPoint);\r\n\t\tgeoPoint = this.rotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n\t\tlet pointInRadians: IPoint = this.project(geoPoint.longitude * $math.RADIANS, geoPoint.latitude * $math.RADIANS);\r\n\t\treturn {\r\n\t\t\tx: $math.round(pointInRadians.x * $math.DEGREES - this.centerPoint.x, 4) * this.scale,\r\n\t\t\ty: $math.round(-pointInRadians.y * $math.DEGREES - this.centerPoint.y, 4) * this.scale\r\n\t\t};*/\r\n\r\n\t\tlet p = this.d3Projection([geoPoint.longitude, geoPoint.latitude]);\r\n\t\tif (p) {\r\n\t\t\treturn { x: p[0], y: p[1] };\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a screen point (x/y) to a geographical point (lat/long)\r\n\t * @param point Screen point (x/y)\r\n\t * @return Geo point (lat/long)\r\n\t */\r\n\tpublic invert(point: IPoint): IGeoPoint {\r\n\t\t/*\r\n\t\tlet pointInRadians: IGeoPoint = this.unproject((point.x / this.scale + this.centerPoint.x) * $math.RADIANS, (-point.y / this.scale - this.centerPoint.y) * $math.RADIANS);\r\n\r\n\t\tlet geoPoint = { longitude: pointInRadians.longitude * $math.DEGREES, latitude: pointInRadians.latitude * $math.DEGREES };\r\n\r\n\t\tgeoPoint = this.unrotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n\t\t*/\r\n\t\tlet p = this.d3Projection.invert([point.x, point.y]);\r\n\t\tif (p) {\r\n\t\t\treturn { longitude: p[0], latitude: p[1] };\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns X/Y coordinates.\r\n\t * Individual projections will override this method to apply their own\r\n\t * projection logic.\r\n\t * @deprecated\r\n\t * @param lambda [description]\r\n\t * @param phi    [description]\r\n\t * @return X/Y coordinates\r\n\t * @todo Needs description\r\n\t */\r\n\tpublic project(lambda: number, phi: number): IPoint {\r\n\t\treturn this.convert({ longitude: lambda * $math.DEGREES, latitude: phi * $math.DEGREES });\r\n\t}\r\n\r\n\t/**\r\n\t * Returns geographical coordinates (lat/long).\r\n\t * Individual projections will override this method to apply their own\r\n\t * projection logic.\r\n\t * @deprecated\r\n\t * @param x X coordinate\r\n\t * @param y Y coordinate\r\n\t * @return Geographical point\r\n\t * @todo Needs description\r\n\t */\r\n\tpublic unproject(x: number, y: number): IGeoPoint {\r\n\t\treturn this.invert({ x: x, y: y });\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * @deprecated\r\n\t */\r\n\tpublic rotate(geoPoint: IGeoPoint, deltaLongitude: number, deltaLatitude: number, deltaGamma?: number): IGeoPoint {\r\n\r\n\t\tlet deltaLambda = deltaLongitude * $math.RADIANS;\r\n\t\tlet deltaPhi = deltaLatitude * $math.RADIANS;\r\n\t\tdeltaGamma = deltaGamma * $math.RADIANS;\r\n\r\n\t\tlet lambda = geoPoint.longitude * $math.RADIANS + deltaLambda;\r\n\t\tlet phi = geoPoint.latitude * $math.RADIANS;\r\n\r\n\t\tlet cosDeltaPhi = Math.cos(deltaPhi);\r\n\t\tlet sinDeltaPhi = Math.sin(deltaPhi);\r\n\t\tlet cosDeltaGamma = Math.cos(deltaGamma);\r\n\t\tlet sinDeltaGamma = Math.sin(deltaGamma);\r\n\r\n\t\tlet cosPhi = Math.cos(phi);\r\n\r\n\t\tlet x = Math.cos(lambda) * cosPhi;\r\n\t\tlet y = Math.sin(lambda) * cosPhi;\r\n\t\tlet z = Math.sin(phi);\r\n\t\tlet k = z * cosDeltaPhi + x * sinDeltaPhi;\r\n\r\n\t\treturn { longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), latitude: $math.DEGREES * Math.asin(k * cosDeltaGamma + y * sinDeltaGamma) };\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * @deprecated\r\n\t */\r\n\tpublic unrotate(geoPoint: IGeoPoint, deltaLongitude: number, deltaLatitude: number, deltaGamma?: number): IGeoPoint {\r\n\r\n\t\tlet deltaLambda = deltaLongitude * $math.RADIANS;\r\n\t\tlet deltaPhi = deltaLatitude * $math.RADIANS;\r\n\t\tdeltaGamma = deltaGamma * $math.RADIANS;\r\n\r\n\t\tlet lambda = geoPoint.longitude * $math.RADIANS - deltaLambda;\r\n\t\tlet phi = geoPoint.latitude * $math.RADIANS;\r\n\r\n\t\tlet cosDeltaPhi = Math.cos(deltaPhi);\r\n\t\tlet sinDeltaPhi = Math.sin(deltaPhi);\r\n\t\tlet cosDeltaGamma = Math.cos(deltaGamma);\r\n\t\tlet sinDeltaGamma = Math.sin(deltaGamma);\r\n\r\n\t\tlet cosPhi = Math.cos(phi);\r\n\r\n\t\tlet x = Math.cos(lambda) * cosPhi;\r\n\t\tlet y = Math.sin(lambda) * cosPhi;\r\n\t\tlet z = Math.sin(phi);\r\n\t\tlet k = z * cosDeltaGamma - y * sinDeltaGamma;\r\n\r\n\t\treturn { longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), latitude: $math.DEGREES * Math.asin(k * cosDeltaPhi - x * sinDeltaPhi) };\r\n\t}\r\n\r\n\r\n\t//@todo: move to some utils?\r\n\t//@todo: add credits to: https://www.movable-type.co.uk/scripts/latlong.html\r\n\tpublic intermediatePoint(pointA: IGeoPoint, pointB: IGeoPoint, position: number): IGeoPoint {\r\n\t\tlet p = d3geo.geoInterpolate([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude])(position);\r\n\t\treturn { longitude: p[0], latitude: p[1] };\r\n\t};\r\n\r\n\t// returns radians\r\n\tpublic multiDistance(multiGeoLine: Array<Array<IGeoPoint>>): number {\r\n\t\tlet distance = 0;\r\n\t\tfor (let s = 0; s < multiGeoLine.length; s++) {\r\n\t\t\tlet points: Array<IGeoPoint> = multiGeoLine[s];\r\n\t\t\tif (points.length > 1) {\r\n\t\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\t\tlet pointA = points[p - 1];\r\n\t\t\t\t\tlet pointB = points[p];\r\n\t\t\t\t\tdistance += this.distance(pointA, pointB);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn distance;\r\n\t}\r\n\r\n\t// returns radians\r\n\tpublic distance(pointA: IGeoPoint, pointB: IGeoPoint): number {\r\n\t\treturn d3geo.geoDistance([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude]);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts relative position along the line (0-1) into pixel coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic positionToPoint(multiGeoLine: Array<Array<IGeoPoint>>, position: number): IOrientationPoint {\r\n\r\n\t\tif (multiGeoLine) {\r\n\t\t\tlet intermediatePoint = this.positionToGeoPoint(multiGeoLine, position);\r\n\t\t\tlet intermediatePointA = this.positionToGeoPoint(multiGeoLine, position - 0.01);\r\n\t\t\tlet intermediatePointB = this.positionToGeoPoint(multiGeoLine, position + 0.01);\r\n\r\n\t\t\tif (intermediatePointA && intermediatePointB) {\r\n\r\n\t\t\t\tlet point = this.convert(intermediatePoint);\r\n\r\n\t\t\t\tlet pa = this.convert(intermediatePointA);\r\n\t\t\t\tlet pb = this.convert(intermediatePointB);\r\n\r\n\t\t\t\treturn { x: point.x, y: point.y, angle: $math.getAngle(pa, pb) };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn { x: 0, y: 0, angle: 0 };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts relative position along the line (0-1) into pixel coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic positionToGeoPoint(multiGeoLine: Array<Array<IGeoPoint>>, position: number): IGeoPoint {\r\n\r\n\t\tif (multiGeoLine) {\r\n\t\t\tlet totalDistance: number = this.multiDistance(multiGeoLine);\r\n\t\t\tlet currentDistance: number = 0;\r\n\r\n\t\t\tlet distanceAB: number;\r\n\t\t\tlet positionA: number = 0;\r\n\t\t\tlet positionB: number = 0;\r\n\t\t\tlet pointA: IGeoPoint;\r\n\t\t\tlet pointB: IGeoPoint;\r\n\r\n\t\t\tfor (let s = 0; s < multiGeoLine.length; s++) {\r\n\t\t\t\tlet points: Array<IGeoPoint> = multiGeoLine[s];\r\n\t\t\t\tif (points.length > 1) {\r\n\t\t\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\t\t\tpointA = points[p - 1];\r\n\t\t\t\t\t\tpointB = points[p];\r\n\r\n\t\t\t\t\t\tpositionA = currentDistance / totalDistance;\r\n\t\t\t\t\t\tdistanceAB = this.distance(pointA, pointB);\r\n\t\t\t\t\t\tcurrentDistance += distanceAB;\r\n\t\t\t\t\t\tpositionB = currentDistance / totalDistance;\r\n\r\n\t\t\t\t\t\tif (positionA <= position && positionB > position) {\r\n\t\t\t\t\t\t\ts = multiGeoLine.length;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (points.length == 1) {\r\n\t\t\t\t\tpointA = points[0];\r\n\t\t\t\t\tpointB = points[0];\r\n\t\t\t\t\tpositionA = 0;\r\n\t\t\t\t\tpositionB = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (pointA && pointB) {\r\n\t\t\t\tlet positionAB: number = (position - positionA) / (positionB - positionA);\r\n\t\t\t\treturn this.intermediatePoint(pointA, pointB, positionAB);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn { longitude: 0, latitude: 0 };\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Projection\"] = Projection;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}