{"ast":null,"code":"var epsilon = 1e-4,\n    epsilonInverse = 1e4,\n    x0 = -180,\n    x0e = x0 + epsilon,\n    x1 = 180,\n    x1e = x1 - epsilon,\n    y0 = -90,\n    y0e = y0 + epsilon,\n    y1 = 90,\n    y1e = y1 - epsilon;\n\nfunction nonempty(coordinates) {\n  return coordinates.length > 0;\n}\n\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\n\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)]; // pole or antimeridian?\n}\n\nfunction clampPoint(p) {\n  var x = p[0],\n      y = p[1],\n      clamped = false;\n  if (x <= x0e) x = x0, clamped = true;else if (x >= x1e) x = x1, clamped = true;\n  if (y <= y0e) y = y0, clamped = true;else if (y >= y1e) y = y1, clamped = true;\n  return clamped ? [x, y] : p;\n}\n\nfunction clampPoints(points) {\n  return points.map(clampPoint);\n} // For each ring, detect where it crosses the antimeridian or pole.\n\n\nfunction extractFragments(rings, polygon, fragments) {\n  for (var j = 0, m = rings.length; j < m; ++j) {\n    var ring = rings[j].slice(); // By default, assume that this ring doesn’t need any stitching.\n\n    fragments.push({\n      index: -1,\n      polygon: polygon,\n      ring: ring\n    });\n\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n          x = point[0],\n          y = point[1]; // If this is an antimeridian or polar point…\n\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        ring[i] = clampPoint(point); // Advance through any antimeridian or polar points…\n\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n              xk = pointk[0],\n              yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        } // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n\n\n        if (k === i + 1) continue; // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n\n        if (i) {\n          var fragmentBefore = {\n            index: -1,\n            polygon: polygon,\n            ring: ring.slice(0, i + 1)\n          };\n          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        } // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop(); // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n\n\n        if (k >= n) break; // Otherwise, add the remaining ring fragment and continue.\n\n        fragments.push({\n          index: -1,\n          polygon: polygon,\n          ring: ring = ring.slice(k - 1)\n        });\n        ring[0] = normalizePoint(ring[0][1]);\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n} // Now stitch the fragments back together into rings.\n\n\nfunction stitchFragments(fragments) {\n  var i,\n      n = fragments.length; // To connect the fragments start-to-end, create a simple index by end.\n\n  var fragmentByStart = {},\n      fragmentByEnd = {},\n      fragment,\n      start,\n      startFragment,\n      end,\n      endFragment; // For each fragment…\n\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment.ring[0];\n    end = fragment.ring[fragment.ring.length - 1]; // If this fragment is closed, add it as a standalone ring.\n\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment.ring);\n      fragments[i] = null;\n      continue;\n    }\n\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  } // For each open fragment…\n\n\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n\n    if (fragment) {\n      start = fragment.ring[0];\n      end = fragment.ring[fragment.ring.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end]; // If this fragment is closed, add it as a standalone ring.\n\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment.ring);\n        continue;\n      }\n\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment.ring[0]];\n        startFragment.ring.pop(); // drop the shared coordinate\n\n        fragments[startFragment.index] = null;\n        fragment = {\n          index: -1,\n          polygon: startFragment.polygon,\n          ring: startFragment.ring.concat(fragment.ring)\n        };\n\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment.ring);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n        fragment.ring.pop(); // drop the shared coordinate\n\n        fragment = {\n          index: n++,\n          polygon: endFragment.polygon,\n          ring: fragment.ring.concat(endFragment.ring)\n        };\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n      } else {\n        fragment.ring.push(fragment.ring[0]); // close ring\n\n        fragment.polygon.push(fragment.ring);\n      }\n    }\n  }\n}\n\nfunction stitchFeature(input) {\n  var output = {\n    type: \"Feature\",\n    geometry: stitchGeometry(input.geometry)\n  };\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  if (input.properties != null) output.properties = input.properties;\n  return output;\n}\n\nfunction stitchGeometry(input) {\n  if (input == null) return input;\n  var output, fragments, i, n;\n\n  switch (input.type) {\n    case \"GeometryCollection\":\n      output = {\n        type: \"GeometryCollection\",\n        geometries: input.geometries.map(stitchGeometry)\n      };\n      break;\n\n    case \"Point\":\n      output = {\n        type: \"Point\",\n        coordinates: clampPoint(input.coordinates)\n      };\n      break;\n\n    case \"MultiPoint\":\n    case \"LineString\":\n      output = {\n        type: input.type,\n        coordinates: clampPoints(input.coordinates)\n      };\n      break;\n\n    case \"MultiLineString\":\n      output = {\n        type: \"MultiLineString\",\n        coordinates: input.coordinates.map(clampPoints)\n      };\n      break;\n\n    case \"Polygon\":\n      {\n        var polygon = [];\n        extractFragments(input.coordinates, polygon, fragments = []);\n        stitchFragments(fragments);\n        output = {\n          type: \"Polygon\",\n          coordinates: polygon\n        };\n        break;\n      }\n\n    case \"MultiPolygon\":\n      {\n        fragments = [], i = -1, n = input.coordinates.length;\n        var polygons = new Array(n);\n\n        while (++i < n) {\n          extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n        }\n\n        stitchFragments(fragments);\n        output = {\n          type: \"MultiPolygon\",\n          coordinates: polygons.filter(nonempty)\n        };\n        break;\n      }\n\n    default:\n      return input;\n  }\n\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nexport default function (input) {\n  if (input == null) return input;\n\n  switch (input.type) {\n    case \"Feature\":\n      return stitchFeature(input);\n\n    case \"FeatureCollection\":\n      {\n        var output = {\n          type: \"FeatureCollection\",\n          features: input.features.map(stitchFeature)\n        };\n        if (input.bbox != null) output.bbox = input.bbox;\n        return output;\n      }\n\n    default:\n      return stitchGeometry(input);\n  }\n}","map":{"version":3,"sources":["/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/d3-geo-projection/src/stitch.js"],"names":["epsilon","epsilonInverse","x0","x0e","x1","x1e","y0","y0e","y1","y1e","nonempty","coordinates","length","quantize","x","Math","floor","normalizePoint","y","clampPoint","p","clamped","clampPoints","points","map","extractFragments","rings","polygon","fragments","j","m","ring","slice","push","index","i","n","point","k","pointk","xk","yk","fragmentBefore","pop","stitchFragments","fragmentByStart","fragmentByEnd","fragment","start","startFragment","end","endFragment","concat","stitchFeature","input","output","type","geometry","stitchGeometry","id","bbox","properties","geometries","polygons","Array","filter","features"],"mappings":"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","sourcesContent":["var epsilon = 1e-4,\n    epsilonInverse = 1e4,\n    x0 = -180, x0e = x0 + epsilon,\n    x1 = 180, x1e = x1 - epsilon,\n    y0 = -90, y0e = y0 + epsilon,\n    y1 = 90, y1e = y1 - epsilon;\n\nfunction nonempty(coordinates) {\n  return coordinates.length > 0;\n}\n\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\n\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)]; // pole or antimeridian?\n}\n\nfunction clampPoint(p) {\n  var x = p[0], y = p[1], clamped = false;\n  if (x <= x0e) x = x0, clamped = true;\n  else if (x >= x1e) x = x1, clamped = true;\n  if (y <= y0e) y = y0, clamped = true;\n  else if (y >= y1e) y = y1, clamped = true;\n  return clamped ? [x, y] : p;\n}\n\nfunction clampPoints(points) {\n  return points.map(clampPoint);\n}\n\n// For each ring, detect where it crosses the antimeridian or pole.\nfunction extractFragments(rings, polygon, fragments) {\n  for (var j = 0, m = rings.length; j < m; ++j) {\n    var ring = rings[j].slice();\n\n    // By default, assume that this ring doesn’t need any stitching.\n    fragments.push({index: -1, polygon: polygon, ring: ring});\n\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n          x = point[0],\n          y = point[1];\n\n      // If this is an antimeridian or polar point…\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        ring[i] = clampPoint(point);\n\n        // Advance through any antimeridian or polar points…\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n              xk = pointk[0],\n              yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        }\n\n        // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n        if (k === i + 1) continue;\n\n        // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n        if (i) {\n          var fragmentBefore = {index: -1, polygon: polygon, ring: ring.slice(0, i + 1)};\n          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        }\n\n        // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop();\n\n        // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n        if (k >= n) break;\n\n        // Otherwise, add the remaining ring fragment and continue.\n        fragments.push({index: -1, polygon: polygon, ring: ring = ring.slice(k - 1)});\n        ring[0] = normalizePoint(ring[0][1]);\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n}\n\n// Now stitch the fragments back together into rings.\nfunction stitchFragments(fragments) {\n  var i, n = fragments.length;\n\n  // To connect the fragments start-to-end, create a simple index by end.\n  var fragmentByStart = {},\n      fragmentByEnd = {},\n      fragment,\n      start,\n      startFragment,\n      end,\n      endFragment;\n\n  // For each fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment.ring[0];\n    end = fragment.ring[fragment.ring.length - 1];\n\n    // If this fragment is closed, add it as a standalone ring.\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment.ring);\n      fragments[i] = null;\n      continue;\n    }\n\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  }\n\n  // For each open fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    if (fragment) {\n      start = fragment.ring[0];\n      end = fragment.ring[fragment.ring.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end];\n\n      // If this fragment is closed, add it as a standalone ring.\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment.ring);\n        continue;\n      }\n\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment.ring[0]];\n        startFragment.ring.pop(); // drop the shared coordinate\n        fragments[startFragment.index] = null;\n        fragment = {index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring)};\n\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment.ring);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n        fragment.ring.pop(); // drop the shared coordinate\n        fragment = {index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring)};\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n      } else {\n        fragment.ring.push(fragment.ring[0]); // close ring\n        fragment.polygon.push(fragment.ring);\n      }\n    }\n  }\n}\n\nfunction stitchFeature(input) {\n  var output = {type: \"Feature\", geometry: stitchGeometry(input.geometry)};\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  if (input.properties != null) output.properties = input.properties;\n  return output;\n}\n\nfunction stitchGeometry(input) {\n  if (input == null) return input;\n  var output, fragments, i, n;\n  switch (input.type) {\n    case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(stitchGeometry)}; break;\n    case \"Point\": output = {type: \"Point\", coordinates: clampPoint(input.coordinates)}; break;\n    case \"MultiPoint\": case \"LineString\": output = {type: input.type, coordinates: clampPoints(input.coordinates)}; break;\n    case \"MultiLineString\": output = {type: \"MultiLineString\", coordinates: input.coordinates.map(clampPoints)}; break;\n    case \"Polygon\": {\n      var polygon = [];\n      extractFragments(input.coordinates, polygon, fragments = []);\n      stitchFragments(fragments);\n      output = {type: \"Polygon\", coordinates: polygon};\n      break;\n    }\n    case \"MultiPolygon\": {\n      fragments = [], i = -1, n = input.coordinates.length;\n      var polygons = new Array(n);\n      while (++i < n) extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n      stitchFragments(fragments);\n      output = {type: \"MultiPolygon\", coordinates: polygons.filter(nonempty)};\n      break;\n    }\n    default: return input;\n  }\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nexport default function(input) {\n  if (input == null) return input;\n  switch (input.type) {\n    case \"Feature\": return stitchFeature(input);\n    case \"FeatureCollection\": {\n      var output = {type: \"FeatureCollection\", features: input.features.map(stitchFeature)};\n      if (input.bbox != null) output.bbox = input.bbox;\n      return output;\n    }\n    default: return stitchGeometry(input);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}