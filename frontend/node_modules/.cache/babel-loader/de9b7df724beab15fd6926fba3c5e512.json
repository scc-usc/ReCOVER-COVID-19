{"ast":null,"code":"import { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { acos, asin, atan2, cos, degrees, epsilon, halfPi, max, min, pi, radians, sin, sqrt, tan } from \"./math.js\";\n\nfunction wagnerFormula(cx, cy, m1, m2, n) {\n  function forward(lambda, phi) {\n    var s = m1 * sin(m2 * phi),\n        c0 = sqrt(1 - s * s),\n        c1 = sqrt(2 / (1 + c0 * cos(lambda *= n)));\n    return [cx * c0 * c1 * sin(lambda), cy * s * c1];\n  }\n\n  forward.invert = function (x, y) {\n    var t1 = x / cx,\n        t2 = y / cy,\n        p = sqrt(t1 * t1 + t2 * t2),\n        c = 2 * asin(p / 2);\n    return [atan2(x * tan(c), cx * p) / n, p && asin(y * sin(c) / (cy * m1 * p)) / m2];\n  };\n\n  return forward;\n}\n\nexport function wagnerRaw(poleline, parallels, inflation, ratio) {\n  // 60 is always used as reference parallel\n  var phi1 = pi / 3; // sanitizing the input values\n  // poleline and parallels may approximate but never equal 0\n\n  poleline = max(poleline, epsilon);\n  parallels = max(parallels, epsilon); // poleline must be <= 90; parallels may approximate but never equal 180\n\n  poleline = min(poleline, halfPi);\n  parallels = min(parallels, pi - epsilon); // 0 <= inflation <= 99.999\n\n  inflation = max(inflation, 0);\n  inflation = min(inflation, 100 - epsilon); // ratio > 0.\n  // sensible values, i.e. something that renders a map which still can be\n  // recognized as world map, are e.g. 20 <= ratio <= 1000.\n\n  ratio = max(ratio, epsilon); // convert values from boehm notation\n  // areal inflation e.g. from 0 to 1 or 20 to 1.2:\n\n  var vinflation = inflation / 100 + 1; // axial ratio e.g. from 200 to 2:\n\n  var vratio = ratio / 100; // the other ones are a bit more complicated...\n\n  var m2 = acos(vinflation * cos(phi1)) / phi1,\n      m1 = sin(poleline) / sin(m2 * halfPi),\n      n = parallels / pi,\n      k = sqrt(vratio * sin(poleline / 2) / sin(parallels / 2)),\n      cx = k / sqrt(n * m1 * m2),\n      cy = 1 / (k * sqrt(n * m1 * m2));\n  return wagnerFormula(cx, cy, m1, m2, n);\n}\nexport default function wagner() {\n  // default values generate wagner8\n  var poleline = 65 * radians,\n      parallels = 60 * radians,\n      inflation = 20,\n      ratio = 200,\n      mutate = projectionMutator(wagnerRaw),\n      projection = mutate(poleline, parallels, inflation, ratio);\n\n  projection.poleline = function (_) {\n    return arguments.length ? mutate(poleline = +_ * radians, parallels, inflation, ratio) : poleline * degrees;\n  };\n\n  projection.parallels = function (_) {\n    return arguments.length ? mutate(poleline, parallels = +_ * radians, inflation, ratio) : parallels * degrees;\n  };\n\n  projection.inflation = function (_) {\n    return arguments.length ? mutate(poleline, parallels, inflation = +_, ratio) : inflation;\n  };\n\n  projection.ratio = function (_) {\n    return arguments.length ? mutate(poleline, parallels, inflation, ratio = +_) : ratio;\n  };\n\n  return projection.scale(163.775);\n}\nexport function wagner7() {\n  return wagner().poleline(65).parallels(60).inflation(0).ratio(200).scale(172.633);\n}","map":{"version":3,"sources":["/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/d3-geo-projection/src/wagner.js"],"names":["geoProjectionMutator","projectionMutator","acos","asin","atan2","cos","degrees","epsilon","halfPi","max","min","pi","radians","sin","sqrt","tan","wagnerFormula","cx","cy","m1","m2","n","forward","lambda","phi","s","c0","c1","invert","x","y","t1","t2","p","c","wagnerRaw","poleline","parallels","inflation","ratio","phi1","vinflation","vratio","k","wagner","mutate","projection","_","arguments","length","scale","wagner7"],"mappings":"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","sourcesContent":["import {geoProjectionMutator as projectionMutator} from \"d3-geo\";\nimport {acos, asin, atan2, cos, degrees, epsilon, halfPi, max, min, pi, radians, sin, sqrt, tan} from \"./math.js\";\n\nfunction wagnerFormula(cx, cy, m1, m2, n) {\n  function forward(lambda, phi) {\n    var s = m1 * sin(m2 * phi),\n        c0 = sqrt(1 - s * s),\n        c1 = sqrt(2 / (1 + c0 * cos(lambda *= n)));\n    return [\n      cx * c0 * c1 * sin(lambda),\n      cy * s * c1\n    ];\n  }\n\n  forward.invert = function(x, y) {\n    var t1 = x / cx,\n        t2 = y / cy,\n        p = sqrt(t1 * t1 + t2 * t2),\n        c = 2 * asin(p / 2);\n    return [\n      atan2(x * tan(c), cx * p) / n,\n      p && asin(y * sin(c) / (cy * m1 * p)) / m2\n    ];\n  };\n\n  return forward;\n}\n\nexport function wagnerRaw(poleline, parallels, inflation, ratio) {\n  // 60 is always used as reference parallel\n  var phi1 = pi / 3;\n\n  // sanitizing the input values\n  // poleline and parallels may approximate but never equal 0\n  poleline = max(poleline, epsilon);\n  parallels = max(parallels, epsilon);\n  // poleline must be <= 90; parallels may approximate but never equal 180\n  poleline = min(poleline, halfPi);\n  parallels = min(parallels, pi - epsilon);\n  // 0 <= inflation <= 99.999\n  inflation = max(inflation, 0);\n  inflation = min(inflation, 100 - epsilon);\n  // ratio > 0.\n  // sensible values, i.e. something that renders a map which still can be\n  // recognized as world map, are e.g. 20 <= ratio <= 1000.\n  ratio = max(ratio, epsilon);\n\n  // convert values from boehm notation\n  // areal inflation e.g. from 0 to 1 or 20 to 1.2:\n  var vinflation = inflation/100 + 1;\n  // axial ratio e.g. from 200 to 2:\n  var vratio  = ratio / 100;\n  // the other ones are a bit more complicated...\n  var m2 = acos(vinflation * cos(phi1)) / phi1,\n      m1 = sin(poleline) / sin(m2 * halfPi),\n      n = parallels / pi,\n      k = sqrt(vratio * sin(poleline / 2) / sin(parallels / 2)),\n      cx = k / sqrt(n * m1 * m2),\n      cy = 1 / (k * sqrt(n * m1 * m2));\n\n  return wagnerFormula(cx, cy, m1, m2, n);\n}\n\nexport default function wagner() {\n  // default values generate wagner8\n  var poleline = 65 * radians,\n      parallels = 60 * radians,\n      inflation = 20,\n      ratio = 200,\n      mutate = projectionMutator(wagnerRaw),\n      projection = mutate(poleline, parallels, inflation, ratio);\n\n  projection.poleline = function(_) {\n    return arguments.length ? mutate(poleline = +_ * radians, parallels, inflation, ratio) : poleline * degrees;\n  };\n\n  projection.parallels = function(_) {\n    return arguments.length ? mutate(poleline, parallels = +_ * radians, inflation, ratio) : parallels * degrees;\n  };\n  projection.inflation = function(_) {\n    return arguments.length ? mutate(poleline, parallels, inflation = +_, ratio) : inflation;\n  };\n  projection.ratio = function(_) {\n    return arguments.length ? mutate(poleline, parallels, inflation, ratio = +_) : ratio;\n  };\n\n  return projection\n    .scale(163.775);\n}\n\nexport function wagner7() {\n  return wagner()\n      .poleline(65)\n      .parallels(60)\n      .inflation(0)\n      .ratio(200)\n      .scale(172.633);\n}\n"]},"metadata":{},"sourceType":"module"}