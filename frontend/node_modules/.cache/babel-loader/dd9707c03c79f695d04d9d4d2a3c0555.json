{"ast":null,"code":"import PropTypes from 'prop-types';\nimport { scaleLinear, scaleLog, scalePoint, scaleUtc, scaleTime } from 'd3-scale';\nimport { utcParse, timeParse } from 'd3-time-format';\nimport uniq from 'lodash/uniq';\nimport uniqBy from 'lodash/uniqBy';\nimport sortBy from 'lodash/sortBy';\nimport last from 'lodash/last';\nimport isDate from 'lodash/isDate';\n\nvar linearScale = function linearScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = stacked === true ? values.minStacked : values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = stacked === true ? values.maxStacked : values.max;\n  }\n\n  var scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0]);\n  if (reverse === true) scale.domain([maxValue, minValue]);else scale.domain([minValue, maxValue]);\n  scale.type = 'linear';\n  scale.stacked = stacked;\n  return scale;\n};\n\nvar linearScalePropTypes = {\n  type: PropTypes.oneOf(['linear']).isRequired,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  stacked: PropTypes.bool,\n  reverse: PropTypes.bool\n};\n\nvar logScale = function logScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$base = _ref.base,\n      base = _ref$base === void 0 ? 10 : _ref$base,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var hasZero = values.all.some(function (v) {\n    return v === 0;\n  });\n  var sign;\n  var hasMixedSign = false;\n  values.all.forEach(function (v) {\n    if (hasMixedSign === true) return;\n\n    if (sign === undefined) {\n      sign = Math.sign(v);\n    } else if (Math.sign(v) !== sign) {\n      hasMixedSign = true;\n    }\n  });\n\n  if (hasZero || hasMixedSign) {\n    throw new Error([\"a log scale domain must be strictly-positive or strictly-negative,\", \"and must not include or cross zero.\"].join('\\n'));\n  }\n\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  }\n\n  var scale = scaleLog().domain([minValue, maxValue]).rangeRound(axis === 'x' ? [0, size] : [size, 0]).base(base).nice();\n  scale.type = 'log';\n  return scale;\n};\n\nvar logScalePropTypes = {\n  type: PropTypes.oneOf(['log']).isRequired,\n  base: PropTypes.number,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number])\n};\n\nvar pointScale = function pointScale(_ref, xy, width, height) {\n  var axis = _ref.axis;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var scale = scalePoint().range([0, size]).domain(values.all);\n  scale.type = 'point';\n  return scale;\n};\n\nvar pointScalePropTypes = {\n  type: PropTypes.oneOf(['point']).isRequired\n};\n\nvar _precisionCutOffsByTy;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar TIME_PRECISION_MILLISECOND = 'millisecond';\nvar TIME_PRECISION_SECOND = 'second';\nvar TIME_PRECISION_MINUTE = 'minute';\nvar TIME_PRECISION_HOUR = 'hour';\nvar TIME_PRECISION_DAY = 'day';\nvar TIME_PRECISION_MONTH = 'month';\nvar TIME_PRECISION_YEAR = 'year';\nvar timePrecisions = [TIME_PRECISION_MILLISECOND, TIME_PRECISION_SECOND, TIME_PRECISION_MINUTE, TIME_PRECISION_HOUR, TIME_PRECISION_DAY, TIME_PRECISION_MONTH, TIME_PRECISION_YEAR];\nvar precisionCutOffs = [function (date) {\n  return date.setMilliseconds(0);\n}, function (date) {\n  return date.setSeconds(0);\n}, function (date) {\n  return date.setMinutes(0);\n}, function (date) {\n  return date.setHours(0);\n}, function (date) {\n  return date.setDate(1);\n}, function (date) {\n  return date.setMonth(0);\n}];\nvar precisionCutOffsByType = (_precisionCutOffsByTy = {}, _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MILLISECOND, []), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_SECOND, precisionCutOffs.slice(0, 1)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MINUTE, precisionCutOffs.slice(0, 2)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_HOUR, precisionCutOffs.slice(0, 3)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_DAY, precisionCutOffs.slice(0, 4)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MONTH, precisionCutOffs.slice(0, 5)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_YEAR, precisionCutOffs.slice(0, 6)), _precisionCutOffsByTy);\n\nvar createPrecisionMethod = function createPrecisionMethod(precision) {\n  return function (date) {\n    precisionCutOffsByType[precision].forEach(function (cutOff) {\n      cutOff(date);\n    });\n    return date;\n  };\n};\n\nvar createDateNormalizer = function createDateNormalizer(_ref) {\n  var _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var precisionFn = createPrecisionMethod(precision);\n  if (format === 'native') return function (v) {\n    return precisionFn(v);\n  };\n  var parseTime = useUTC ? utcParse(format) : timeParse(format);\n  return function (v) {\n    return precisionFn(parseTime(v));\n  };\n};\n\nvar timeScale = function timeScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? TIME_PRECISION_MILLISECOND : _ref$precision,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var normalize = createDateNormalizer({\n    format: format,\n    precision: precision,\n    useUTC: useUTC\n  });\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  } else if (format !== 'native') {\n    minValue = normalize(values.min);\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  } else if (format !== 'native') {\n    maxValue = normalize(values.max);\n  }\n\n  var scale = useUTC ? scaleUtc() : scaleTime();\n  scale.domain([minValue, maxValue]).range([0, size]);\n  scale.type = 'time';\n  scale.useUTC = useUTC;\n  return scale;\n};\n\nvar timeScalePropTypes = {\n  type: PropTypes.oneOf(['time']).isRequired,\n  format: PropTypes.string,\n  precision: PropTypes.oneOf(timePrecisions)\n};\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(Object(source));\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty$1(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty$1(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar getOtherAxis = function getOtherAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n};\n\nvar compareValues = function compareValues(a, b) {\n  return a === b;\n};\n\nvar compareDateValues = function compareDateValues(a, b) {\n  return a.getTime() === b.getTime();\n};\n\nvar computeXYScalesForSeries = function computeXYScalesForSeries(_series, xScaleSpec, yScaleSpec, width, height) {\n  var series = _series.map(function (serie) {\n    return _objectSpread({}, serie, {\n      data: serie.data.map(function (d) {\n        return {\n          data: _objectSpread({}, d)\n        };\n      })\n    });\n  });\n\n  var xy = generateSeriesXY(series, xScaleSpec, yScaleSpec);\n\n  if (xScaleSpec.stacked === true) {\n    stackX(yScaleSpec.type, xy, series);\n  }\n\n  if (yScaleSpec.stacked === true) {\n    stackY(xScaleSpec.type, xy, series);\n  }\n\n  var xScale = computeScale(_objectSpread({}, xScaleSpec, {\n    axis: 'x'\n  }), xy, width, height);\n  var yScale = computeScale(_objectSpread({}, yScaleSpec, {\n    axis: 'y'\n  }), xy, width, height);\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      d.position = {\n        x: xScale.stacked === true ? d.data.xStacked === null ? null : xScale(d.data.xStacked) : d.data.x === null ? null : xScale(d.data.x),\n        y: yScale.stacked === true ? d.data.yStacked === null ? null : yScale(d.data.yStacked) : d.data.y === null ? null : yScale(d.data.y)\n      };\n    });\n  });\n  return _objectSpread({}, xy, {\n    series: series,\n    xScale: xScale,\n    yScale: yScale\n  });\n};\n\nvar computeScale = function computeScale(spec, xy, width, height) {\n  if (spec.type === 'linear') return linearScale(spec, xy, width, height);else if (spec.type === 'point') return pointScale(spec, xy, width, height);else if (spec.type === 'time') return timeScale(spec, xy, width, height);else if (spec.type === 'log') return logScale(spec, xy, width, height);\n};\n\nvar generateSeriesXY = function generateSeriesXY(series, xScaleSpec, yScaleSpec) {\n  return {\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec)\n  };\n};\n\nvar generateSeriesAxis = function generateSeriesAxis(series, axis, scaleSpec) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref$getValue = _ref.getValue,\n      getValue = _ref$getValue === void 0 ? function (d) {\n    return d.data[axis];\n  } : _ref$getValue,\n      _ref$setValue = _ref.setValue,\n      setValue = _ref$setValue === void 0 ? function (d, v) {\n    d.data[axis] = v;\n  } : _ref$setValue;\n\n  if (scaleSpec.type === 'linear') {\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        setValue(d, getValue(d) === null ? null : parseFloat(getValue(d)));\n      });\n    });\n  } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n    var parseTime = createDateNormalizer(scaleSpec);\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        setValue(d, getValue(d) === null ? null : parseTime(getValue(d)));\n      });\n    });\n  }\n\n  var all = [];\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      all.push(getValue(d));\n    });\n  });\n  var min, max;\n\n  if (scaleSpec.type === 'linear') {\n    all = uniq(all);\n    all = sortBy(all, function (v) {\n      return v;\n    });\n    min = Math.min.apply(Math, _toConsumableArray(all));\n    max = Math.max.apply(Math, _toConsumableArray(all));\n  } else if (scaleSpec.type === 'time') {\n    all = uniqBy(all, function (v) {\n      return v.getTime();\n    });\n    all = all.slice(0).sort(function (a, b) {\n      return b - a;\n    }).reverse();\n    min = all[0];\n    max = last(all);\n  } else {\n    all = uniq(all);\n    min = all[0];\n    max = last(all);\n  }\n\n  return {\n    all: all,\n    min: min,\n    max: max\n  };\n};\n\nvar stackAxis = function stackAxis(axis, otherType, xy, series) {\n  var otherAxis = getOtherAxis(axis);\n  var all = [];\n  xy[otherAxis].all.forEach(function (v) {\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    var stack = [];\n    series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      var value = null;\n      var stackValue = null;\n\n      if (datum !== undefined) {\n        value = datum.data[axis];\n\n        if (value !== null) {\n          var head = last(stack);\n\n          if (head === undefined) {\n            stackValue = value;\n          } else if (head !== null) {\n            stackValue = head + value;\n          }\n        }\n\n        datum.data[\"\".concat(axis, \"Stacked\")] = stackValue;\n      }\n\n      stack.push(stackValue);\n      all.push(stackValue);\n    });\n  });\n  all = all.filter(function (v) {\n    return v !== null;\n  });\n  xy[axis].minStacked = Math.min.apply(Math, _toConsumableArray(all));\n  xy[axis].maxStacked = Math.max.apply(Math, _toConsumableArray(all));\n};\n\nvar stackX = function stackX(xy, otherType, series) {\n  return stackAxis('x', xy, otherType, series);\n};\n\nvar stackY = function stackY(xy, otherType, series) {\n  return stackAxis('y', xy, otherType, series);\n};\n\nvar computeAxisSlices = function computeAxisSlices(axis, data) {\n  var otherAxis = getOtherAxis(axis);\n  return data[otherAxis].all.map(function (v) {\n    var _slice;\n\n    var slice = (_slice = {\n      id: v\n    }, _defineProperty$1(_slice, otherAxis, data[\"\".concat(otherAxis, \"Scale\")](v)), _defineProperty$1(_slice, \"data\", []), _slice);\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    data.series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n\n      if (datum !== undefined) {\n        slice.data.push(_objectSpread({}, datum, {\n          serie: serie\n        }));\n      }\n    });\n    slice.data.reverse();\n    return slice;\n  });\n};\n\nvar computeXSlices = function computeXSlices(data) {\n  return computeAxisSlices('x', data);\n};\n\nvar computeYSlices = function computeYSlices(data) {\n  return computeAxisSlices('y', data);\n};\n\nvar scalePropType = PropTypes.oneOfType([PropTypes.shape(linearScalePropTypes), PropTypes.shape(pointScalePropTypes), PropTypes.shape(timeScalePropTypes), PropTypes.shape(logScalePropTypes)]);\nexport { compareDateValues, compareValues, computeAxisSlices, computeScale, computeXSlices, computeXYScalesForSeries, computeYSlices, generateSeriesAxis, generateSeriesXY, getOtherAxis, linearScale, linearScalePropTypes, logScale, logScalePropTypes, pointScale, pointScalePropTypes, scalePropType, stackAxis, stackX, stackY, timeScale, timeScalePropTypes };","map":{"version":3,"sources":["/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/@nivo/scales/dist/nivo-scales.esm.js"],"names":["PropTypes","scaleLinear","scaleLog","scalePoint","scaleUtc","scaleTime","utcParse","timeParse","uniq","uniqBy","sortBy","last","isDate","linearScale","_ref","xy","width","height","axis","_ref$min","min","_ref$max","max","_ref$stacked","stacked","_ref$reverse","reverse","values","size","minValue","minStacked","maxValue","maxStacked","scale","rangeRound","domain","type","linearScalePropTypes","oneOf","isRequired","oneOfType","number","bool","logScale","_ref$base","base","hasZero","all","some","v","sign","hasMixedSign","forEach","undefined","Math","Error","join","nice","logScalePropTypes","pointScale","range","pointScalePropTypes","_precisionCutOffsByTy","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","TIME_PRECISION_MILLISECOND","TIME_PRECISION_SECOND","TIME_PRECISION_MINUTE","TIME_PRECISION_HOUR","TIME_PRECISION_DAY","TIME_PRECISION_MONTH","TIME_PRECISION_YEAR","timePrecisions","precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","slice","createPrecisionMethod","precision","cutOff","createDateNormalizer","_ref$format","format","_ref$precision","_ref$useUTC","useUTC","precisionFn","parseTime","timeScale","normalize","timeScalePropTypes","string","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","i","arr2","length","_objectSpread","target","arguments","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","_defineProperty$1","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeXYScalesForSeries","_series","xScaleSpec","yScaleSpec","series","map","serie","data","d","generateSeriesXY","stackX","stackY","xScale","computeScale","yScale","position","x","xStacked","y","yStacked","spec","generateSeriesAxis","scaleSpec","_ref$getValue","getValue","_ref$setValue","setValue","parseFloat","push","apply","sort","stackAxis","otherType","otherAxis","compare","stack","datum","find","stackValue","head","computeAxisSlices","_slice","id","computeXSlices","computeYSlices","scalePropType","shape"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types';\nimport { scaleLinear, scaleLog, scalePoint, scaleUtc, scaleTime } from 'd3-scale';\nimport { utcParse, timeParse } from 'd3-time-format';\nimport uniq from 'lodash/uniq';\nimport uniqBy from 'lodash/uniqBy';\nimport sortBy from 'lodash/sortBy';\nimport last from 'lodash/last';\nimport isDate from 'lodash/isDate';\n\nvar linearScale = function linearScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var minValue = min;\n  if (min === 'auto') {\n    minValue = stacked === true ? values.minStacked : values.min;\n  }\n  var maxValue = max;\n  if (max === 'auto') {\n    maxValue = stacked === true ? values.maxStacked : values.max;\n  }\n  var scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0]);\n  if (reverse === true) scale.domain([maxValue, minValue]);else scale.domain([minValue, maxValue]);\n  scale.type = 'linear';\n  scale.stacked = stacked;\n  return scale;\n};\nvar linearScalePropTypes = {\n  type: PropTypes.oneOf(['linear']).isRequired,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  stacked: PropTypes.bool,\n  reverse: PropTypes.bool\n};\n\nvar logScale = function logScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$base = _ref.base,\n      base = _ref$base === void 0 ? 10 : _ref$base,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var hasZero = values.all.some(function (v) {\n    return v === 0;\n  });\n  var sign;\n  var hasMixedSign = false;\n  values.all.forEach(function (v) {\n    if (hasMixedSign === true) return;\n    if (sign === undefined) {\n      sign = Math.sign(v);\n    } else if (Math.sign(v) !== sign) {\n      hasMixedSign = true;\n    }\n  });\n  if (hasZero || hasMixedSign) {\n    throw new Error([\"a log scale domain must be strictly-positive or strictly-negative,\", \"and must not include or cross zero.\"].join('\\n'));\n  }\n  var minValue = min;\n  if (min === 'auto') {\n    minValue = values.min;\n  }\n  var maxValue = max;\n  if (max === 'auto') {\n    maxValue = values.max;\n  }\n  var scale = scaleLog().domain([minValue, maxValue]).rangeRound(axis === 'x' ? [0, size] : [size, 0]).base(base).nice();\n  scale.type = 'log';\n  return scale;\n};\nvar logScalePropTypes = {\n  type: PropTypes.oneOf(['log']).isRequired,\n  base: PropTypes.number,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number])\n};\n\nvar pointScale = function pointScale(_ref, xy, width, height) {\n  var axis = _ref.axis;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var scale = scalePoint().range([0, size]).domain(values.all);\n  scale.type = 'point';\n  return scale;\n};\nvar pointScalePropTypes = {\n  type: PropTypes.oneOf(['point']).isRequired\n};\n\nvar _precisionCutOffsByTy;\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar TIME_PRECISION_MILLISECOND = 'millisecond';\nvar TIME_PRECISION_SECOND = 'second';\nvar TIME_PRECISION_MINUTE = 'minute';\nvar TIME_PRECISION_HOUR = 'hour';\nvar TIME_PRECISION_DAY = 'day';\nvar TIME_PRECISION_MONTH = 'month';\nvar TIME_PRECISION_YEAR = 'year';\nvar timePrecisions = [TIME_PRECISION_MILLISECOND, TIME_PRECISION_SECOND, TIME_PRECISION_MINUTE, TIME_PRECISION_HOUR, TIME_PRECISION_DAY, TIME_PRECISION_MONTH, TIME_PRECISION_YEAR];\nvar precisionCutOffs = [function (date) {\n  return date.setMilliseconds(0);\n}, function (date) {\n  return date.setSeconds(0);\n}, function (date) {\n  return date.setMinutes(0);\n}, function (date) {\n  return date.setHours(0);\n}, function (date) {\n  return date.setDate(1);\n}, function (date) {\n  return date.setMonth(0);\n}];\nvar precisionCutOffsByType = (_precisionCutOffsByTy = {}, _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MILLISECOND, []), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_SECOND, precisionCutOffs.slice(0, 1)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MINUTE, precisionCutOffs.slice(0, 2)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_HOUR, precisionCutOffs.slice(0, 3)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_DAY, precisionCutOffs.slice(0, 4)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MONTH, precisionCutOffs.slice(0, 5)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_YEAR, precisionCutOffs.slice(0, 6)), _precisionCutOffsByTy);\nvar createPrecisionMethod = function createPrecisionMethod(precision) {\n  return function (date) {\n    precisionCutOffsByType[precision].forEach(function (cutOff) {\n      cutOff(date);\n    });\n    return date;\n  };\n};\nvar createDateNormalizer = function createDateNormalizer(_ref) {\n  var _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var precisionFn = createPrecisionMethod(precision);\n  if (format === 'native') return function (v) {\n    return precisionFn(v);\n  };\n  var parseTime = useUTC ? utcParse(format) : timeParse(format);\n  return function (v) {\n    return precisionFn(parseTime(v));\n  };\n};\n\nvar timeScale = function timeScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? TIME_PRECISION_MILLISECOND : _ref$precision,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var normalize = createDateNormalizer({\n    format: format,\n    precision: precision,\n    useUTC: useUTC\n  });\n  var minValue = min;\n  if (min === 'auto') {\n    minValue = values.min;\n  } else if (format !== 'native') {\n    minValue = normalize(values.min);\n  }\n  var maxValue = max;\n  if (max === 'auto') {\n    maxValue = values.max;\n  } else if (format !== 'native') {\n    maxValue = normalize(values.max);\n  }\n  var scale = useUTC ? scaleUtc() : scaleTime();\n  scale.domain([minValue, maxValue]).range([0, size]);\n  scale.type = 'time';\n  scale.useUTC = useUTC;\n  return scale;\n};\nvar timeScalePropTypes = {\n  type: PropTypes.oneOf(['time']).isRequired,\n  format: PropTypes.string,\n  precision: PropTypes.oneOf(timePrecisions)\n};\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(Object(source)); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }\nfunction _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar getOtherAxis = function getOtherAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n};\nvar compareValues = function compareValues(a, b) {\n  return a === b;\n};\nvar compareDateValues = function compareDateValues(a, b) {\n  return a.getTime() === b.getTime();\n};\nvar computeXYScalesForSeries = function computeXYScalesForSeries(_series, xScaleSpec, yScaleSpec, width, height) {\n  var series = _series.map(function (serie) {\n    return _objectSpread({}, serie, {\n      data: serie.data.map(function (d) {\n        return {\n          data: _objectSpread({}, d)\n        };\n      })\n    });\n  });\n  var xy = generateSeriesXY(series, xScaleSpec, yScaleSpec);\n  if (xScaleSpec.stacked === true) {\n    stackX(yScaleSpec.type, xy, series);\n  }\n  if (yScaleSpec.stacked === true) {\n    stackY(xScaleSpec.type, xy, series);\n  }\n  var xScale = computeScale(_objectSpread({}, xScaleSpec, {\n    axis: 'x'\n  }), xy, width, height);\n  var yScale = computeScale(_objectSpread({}, yScaleSpec, {\n    axis: 'y'\n  }), xy, width, height);\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      d.position = {\n        x: xScale.stacked === true ? d.data.xStacked === null ? null : xScale(d.data.xStacked) : d.data.x === null ? null : xScale(d.data.x),\n        y: yScale.stacked === true ? d.data.yStacked === null ? null : yScale(d.data.yStacked) : d.data.y === null ? null : yScale(d.data.y)\n      };\n    });\n  });\n  return _objectSpread({}, xy, {\n    series: series,\n    xScale: xScale,\n    yScale: yScale\n  });\n};\nvar computeScale = function computeScale(spec, xy, width, height) {\n  if (spec.type === 'linear') return linearScale(spec, xy, width, height);else if (spec.type === 'point') return pointScale(spec, xy, width, height);else if (spec.type === 'time') return timeScale(spec, xy, width, height);else if (spec.type === 'log') return logScale(spec, xy, width, height);\n};\nvar generateSeriesXY = function generateSeriesXY(series, xScaleSpec, yScaleSpec) {\n  return {\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec)\n  };\n};\nvar generateSeriesAxis = function generateSeriesAxis(series, axis, scaleSpec) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref$getValue = _ref.getValue,\n      getValue = _ref$getValue === void 0 ? function (d) {\n    return d.data[axis];\n  } : _ref$getValue,\n      _ref$setValue = _ref.setValue,\n      setValue = _ref$setValue === void 0 ? function (d, v) {\n    d.data[axis] = v;\n  } : _ref$setValue;\n  if (scaleSpec.type === 'linear') {\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        setValue(d, getValue(d) === null ? null : parseFloat(getValue(d)));\n      });\n    });\n  } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n    var parseTime = createDateNormalizer(scaleSpec);\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        setValue(d, getValue(d) === null ? null : parseTime(getValue(d)));\n      });\n    });\n  }\n  var all = [];\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      all.push(getValue(d));\n    });\n  });\n  var min, max;\n  if (scaleSpec.type === 'linear') {\n    all = uniq(all);\n    all = sortBy(all, function (v) {\n      return v;\n    });\n    min = Math.min.apply(Math, _toConsumableArray(all));\n    max = Math.max.apply(Math, _toConsumableArray(all));\n  } else if (scaleSpec.type === 'time') {\n    all = uniqBy(all, function (v) {\n      return v.getTime();\n    });\n    all = all.slice(0).sort(function (a, b) {\n      return b - a;\n    }).reverse();\n    min = all[0];\n    max = last(all);\n  } else {\n    all = uniq(all);\n    min = all[0];\n    max = last(all);\n  }\n  return {\n    all: all,\n    min: min,\n    max: max\n  };\n};\nvar stackAxis = function stackAxis(axis, otherType, xy, series) {\n  var otherAxis = getOtherAxis(axis);\n  var all = [];\n  xy[otherAxis].all.forEach(function (v) {\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    var stack = [];\n    series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      var value = null;\n      var stackValue = null;\n      if (datum !== undefined) {\n        value = datum.data[axis];\n        if (value !== null) {\n          var head = last(stack);\n          if (head === undefined) {\n            stackValue = value;\n          } else if (head !== null) {\n            stackValue = head + value;\n          }\n        }\n        datum.data[\"\".concat(axis, \"Stacked\")] = stackValue;\n      }\n      stack.push(stackValue);\n      all.push(stackValue);\n    });\n  });\n  all = all.filter(function (v) {\n    return v !== null;\n  });\n  xy[axis].minStacked = Math.min.apply(Math, _toConsumableArray(all));\n  xy[axis].maxStacked = Math.max.apply(Math, _toConsumableArray(all));\n};\nvar stackX = function stackX(xy, otherType, series) {\n  return stackAxis('x', xy, otherType, series);\n};\nvar stackY = function stackY(xy, otherType, series) {\n  return stackAxis('y', xy, otherType, series);\n};\nvar computeAxisSlices = function computeAxisSlices(axis, data) {\n  var otherAxis = getOtherAxis(axis);\n  return data[otherAxis].all.map(function (v) {\n    var _slice;\n    var slice = (_slice = {\n      id: v\n    }, _defineProperty$1(_slice, otherAxis, data[\"\".concat(otherAxis, \"Scale\")](v)), _defineProperty$1(_slice, \"data\", []), _slice);\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    data.series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      if (datum !== undefined) {\n        slice.data.push(_objectSpread({}, datum, {\n          serie: serie\n        }));\n      }\n    });\n    slice.data.reverse();\n    return slice;\n  });\n};\nvar computeXSlices = function computeXSlices(data) {\n  return computeAxisSlices('x', data);\n};\nvar computeYSlices = function computeYSlices(data) {\n  return computeAxisSlices('y', data);\n};\n\nvar scalePropType = PropTypes.oneOfType([PropTypes.shape(linearScalePropTypes), PropTypes.shape(pointScalePropTypes), PropTypes.shape(timeScalePropTypes), PropTypes.shape(logScalePropTypes)]);\n\nexport { compareDateValues, compareValues, computeAxisSlices, computeScale, computeXSlices, computeXYScalesForSeries, computeYSlices, generateSeriesAxis, generateSeriesXY, getOtherAxis, linearScale, linearScalePropTypes, logScale, logScalePropTypes, pointScale, pointScalePropTypes, scalePropType, stackAxis, stackX, stackY, timeScale, timeScalePropTypes };\n"]},"metadata":{},"sourceType":"module"}