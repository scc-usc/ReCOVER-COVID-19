{"ast":null,"code":"import { geoEquirectangular, geoOrthographic } from \"d3-geo\";\nimport { asin, atan, degrees, radians, sin, tan } from \"./math.js\";\n\nfunction gilbertForward(point) {\n  return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n}\n\nfunction gilbertInvert(point) {\n  return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n}\n\nexport default function (projectionType) {\n  if (projectionType == null) projectionType = geoOrthographic;\n  var projection = projectionType(),\n      equirectangular = geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting\n\n  function gilbert(point) {\n    return projection(gilbertForward(point));\n  }\n\n  if (projection.invert) gilbert.invert = function (point) {\n    return gilbertInvert(projection.invert(point));\n  };\n\n  gilbert.stream = function (stream) {\n    var s1 = projection.stream(stream),\n        s0 = equirectangular.stream({\n      point: function point(lambda, phi) {\n        s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees);\n      },\n      lineStart: function lineStart() {\n        s1.lineStart();\n      },\n      lineEnd: function lineEnd() {\n        s1.lineEnd();\n      },\n      polygonStart: function polygonStart() {\n        s1.polygonStart();\n      },\n      polygonEnd: function polygonEnd() {\n        s1.polygonEnd();\n      }\n    });\n    s0.sphere = s1.sphere;\n    return s0;\n  };\n\n  function property(name) {\n    gilbert[name] = function () {\n      return arguments.length ? (projection[name].apply(projection, arguments), gilbert) : projection[name]();\n    };\n  }\n\n  gilbert.rotate = function (_) {\n    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n  };\n\n  gilbert.center = function (_) {\n    return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n  };\n\n  property(\"angle\");\n  property(\"clipAngle\");\n  property(\"clipExtent\");\n  property(\"fitExtent\");\n  property(\"fitHeight\");\n  property(\"fitSize\");\n  property(\"fitWidth\");\n  property(\"scale\");\n  property(\"translate\");\n  property(\"precision\");\n  return gilbert.scale(249.5);\n}","map":{"version":3,"sources":["/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/d3-geo-projection/src/gilbert.js"],"names":["geoEquirectangular","geoOrthographic","asin","atan","degrees","radians","sin","tan","gilbertForward","point","gilbertInvert","projectionType","projection","equirectangular","scale","precision","clipAngle","translate","gilbert","invert","stream","s1","s0","lambda","phi","lineStart","lineEnd","polygonStart","polygonEnd","sphere","property","name","arguments","length","apply","rotate","_","center"],"mappings":"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","sourcesContent":["import {geoEquirectangular, geoOrthographic} from \"d3-geo\";\nimport {asin, atan, degrees, radians, sin, tan} from \"./math.js\";\n\nfunction gilbertForward(point) {\n  return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n}\n\nfunction gilbertInvert(point) {\n  return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n}\n\nexport default function(projectionType) {\n  if (projectionType == null) projectionType = geoOrthographic;\n  var projection = projectionType(),\n      equirectangular = geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting\n\n  function gilbert(point) {\n    return projection(gilbertForward(point));\n  }\n\n  if (projection.invert) gilbert.invert = function(point) {\n    return gilbertInvert(projection.invert(point));\n  };\n\n  gilbert.stream = function(stream) {\n    var s1 = projection.stream(stream), s0 = equirectangular.stream({\n      point: function(lambda, phi) { s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees); },\n      lineStart: function() { s1.lineStart(); },\n      lineEnd: function() { s1.lineEnd(); },\n      polygonStart: function() { s1.polygonStart(); },\n      polygonEnd: function() { s1.polygonEnd(); }\n    });\n    s0.sphere = s1.sphere;\n    return s0;\n  };\n\n  function property(name) {\n    gilbert[name] = function() {\n      return arguments.length ? (projection[name].apply(projection, arguments), gilbert) : projection[name]();\n    };\n  }\n\n  gilbert.rotate = function(_) {\n    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n  };\n\n  gilbert.center = function(_) {\n    return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n  };\n\n  property(\"angle\");\n  property(\"clipAngle\");\n  property(\"clipExtent\");\n  property(\"fitExtent\");\n  property(\"fitHeight\");\n  property(\"fitSize\");\n  property(\"fitWidth\");\n  property(\"scale\");\n  property(\"translate\");\n  property(\"precision\");\n\n  return gilbert\n      .scale(249.5);\n}\n"]},"metadata":{},"sourceType":"module"}